<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Science on 평범한 개발자</title>
    <link>/categories/computer-science/</link>
    <description>Recent content in Computer Science on 평범한 개발자</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 08 May 2022 01:37:45 +0900</lastBuildDate>
    <atom:link href="/categories/computer-science/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Device Tree Overlay</title>
      <link>/posts/device-tree-overlay/</link>
      <pubDate>Sun, 08 May 2022 01:37:45 +0900</pubDate>
      <guid>/posts/device-tree-overlay/</guid>
      <description>&lt;h1 id=&#34;ramoops-덕분에-알게된-오버레이&#34;&gt;Ramoops 덕분에 알게된 오버레이&lt;/h1&gt;&#xA;&lt;p&gt;며칠전 리눅스에서의 Tracing 방법에 대해 공부하다가 찾아낸 세미나 영상에서 ramoops 라는 것을 알게 되었다.&#xA;ramoops는 커널이 oops/panic 이 발생하면서 warm reset 되었을 경우 재부팅 이후에 pstore (persistent store)을 이용하여 이전에 기록된 dmesg 나&#xA;user 콘솔의 기록을 확인할 수 있도록 하는 logger 이다. ramoops 는 cold reset 이 되면 기록이 남아있지 않는다는 단점이 있어&#xA;최근에는 ramoops 대신 blk oops/panic logger 를 사용하기도 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Stack Protector와 디버깅 이야기</title>
      <link>/posts/stack-protector%EC%99%80-%EB%94%94%EB%B2%84%EA%B9%85-%EC%9D%B4%EC%95%BC%EA%B8%B0/</link>
      <pubDate>Thu, 03 Feb 2022 15:00:45 +0900</pubDate>
      <guid>/posts/stack-protector%EC%99%80-%EB%94%94%EB%B2%84%EA%B9%85-%EC%9D%B4%EC%95%BC%EA%B8%B0/</guid>
      <description>&lt;h1 id=&#34;stack-protector-넌-뭐하는-놈이냐&#34;&gt;Stack Protector, 넌 뭐하는 놈이냐?&lt;/h1&gt;&#xA;&lt;p&gt;현업에서 커널의 &lt;code&gt;CONFIG_STACK_PROTECTOR&lt;/code&gt; 를 활성화하면 커널 부트가 안된다는 이슈가&#xA;보고되었다. Trace32 로 callstack을 살펴보니 내 파트에서 맡고 있는 디바이스 드라이버 코드 때문에&#xA;Stack Overflow가 발생하여 부트가 안되고 있었다. 문제의 지점은 사수가 발견하고 파트장의 수정으로 마무리되었다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>V4L2 Memory Type</title>
      <link>/posts/v4l2-memory-type/</link>
      <pubDate>Sun, 18 Apr 2021 00:32:27 +0900</pubDate>
      <guid>/posts/v4l2-memory-type/</guid>
      <description>&lt;h1 id=&#34;개요&#34;&gt;개요&lt;/h1&gt;&#xA;&lt;p&gt;최근 Capture 디바이스 드라이버 코드의 V4L2 표준화 작업을 위해 한 가지 업무를&#xA;할당 받았다. 거의 일주일 동안 헤매었는데 다른 선임 개발자가 몇 시간 만에 코드를&#xA;수정하니 기대한 결과값이 나오는 것처럼 보였다. 어떻게 동작이 가능했을까 머리로&#xA;이해가 되지않아 토요일 하루종일 V4L2 프레임워크와 LWN 을 뒤져가며 프레임워크를&#xA;분석하고 나니 왜 그동안 이해가 안됐었는지, 그리고 현재 무엇이 잘못됐는지를&#xA;파악할 수 있었다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Little Endian vs. Big Endian</title>
      <link>/posts/little-endian-vs.-big-endian/</link>
      <pubDate>Mon, 27 Jan 2020 22:27:06 +0900</pubDate>
      <guid>/posts/little-endian-vs.-big-endian/</guid>
      <description>&lt;h1 id=&#34;개요&#34;&gt;개요&lt;/h1&gt;&#xA;&lt;p&gt;빅 엔디안과 리틀 엔디안에 관해 업무에서 접할 수 있는 상황과 각각에 해당하는 포인터 연산 예제를 종합적으로 정리하도록 한다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;p class=&#34;imgp&#34;&gt;&#xA;  &lt;img loading=&#34;lazy&#34; src=&#34;/img/endian_compare.png&#34; alt=&#34;Endian 비교&#34;  /&gt;&#xA;&lt;/p&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;엔디안(Endianness)은 컴퓨터의 메모리와 같은 &lt;strong&gt;1차원 공간에 여러 개의 연속된 대상을 배열하는 방법&lt;/strong&gt;을 뜻하며, 바이트를 배열하는 방법을 바이트 순서(Byte-order)라고 한다. &lt;strong&gt;엔디안은 보통 큰 단위가 앞에 나오는 빅 엔디안(Big-Endian)과 작은 단위가 앞에 나오는 리틀 엔디안(Little-Endian)으로 나눌 수 있으며&lt;/strong&gt;, 두 경우에 속하지 않거나 둘 모두 지원하는 것을 미들 엔디안(Middle-Endian)이라 부른다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>색 공간(Color Space)</title>
      <link>/posts/%EC%83%89-%EA%B3%B5%EA%B0%84color-space/</link>
      <pubDate>Sun, 26 Jan 2020 16:39:36 +0900</pubDate>
      <guid>/posts/%EC%83%89-%EA%B3%B5%EA%B0%84color-space/</guid>
      <description>&lt;h1 id=&#34;색-공간-포맷&#34;&gt;색 공간 포맷&lt;/h1&gt;&#xA;&lt;p&gt;업무 상에 사용되는 일반적인 색 인코딩 시스템은 RGB 와 YUV 이다. 그 중에서도 SoC의 각 컴포넌트에서 이미지 처리를 위해 기본으로 요구하는 포맷은 YUV 이다. YUV에는 서브샘플링 방법에 따라 YUV444, YUV422, YUV411, YUV420 등으로 세분화할 수 있는데 각 특징에 따라 실제 표현되는 색이 달라지므로 주의해야 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>지피(Jiffies)</title>
      <link>/posts/%EC%A7%80%ED%94%BCjiffies/</link>
      <pubDate>Sun, 26 May 2019 10:38:40 +0900</pubDate>
      <guid>/posts/%EC%A7%80%ED%94%BCjiffies/</guid>
      <description>&lt;!-- toc --&gt;&#xA;&lt;p&gt;오랜만에 지피에 대한 포스팅을 다시 작성한다(대학생 때 커널 공부를 한&#xA;뒤로 이렇게 별도로 문서를 작성하는 것은 처음인 것 같다). 전역 변수인&#xA;&lt;code&gt;jiffies&lt;/code&gt;에는 시스템 시작 이후 발생한 진동 횟수(tick)이&#xA;저장된다. 시스템 시작 시 커널은 이 값을 0으로 설정하고 타이머&#xA;인터럽트가 발생할 때마다 1씩 증가시킨다. 타이머 인터럽트는 초당 HZ회&#xA;발생하므로, 초당 지피 수는 HZ가 되며, 이에 따라 시스템 가동 시간은&#xA;&lt;code&gt;jiffies / HZ&lt;/code&gt;(초)가 된다.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

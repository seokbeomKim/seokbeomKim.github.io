<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computer Science on 범&#39;s 개발 블로그</title>
    <link>https://seokbeomKim.github.io/categories/computer-science/</link>
    <description>Recent content in Computer Science on 범&#39;s 개발 블로그</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 03 Feb 2022 15:00:45 +0900</lastBuildDate><atom:link href="https://seokbeomKim.github.io/categories/computer-science/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Stack Protector와 디버깅 이야기</title>
      <link>https://seokbeomKim.github.io/posts/stack-protector/</link>
      <pubDate>Thu, 03 Feb 2022 15:00:45 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/stack-protector/</guid>
      <description>Stack Protector, 넌 뭐하는 놈이냐? 현업에서 커널의 CONFIG_STACK_PROTECTOR 를 활성화하면 커널 부트가 안된다는 이슈가 보고되었다. Trace32 로 callstack을 살펴보니 내 파트에서 맡고 있는 디바이스 드라이버 코드 때문에 Stack Overflow가 발생하여 부트가 안되고 있었다. 문제의 지점은 사수가 발견하고 파트장의 수정으로 마무리되었다.
하지만 이슈가 마무리 되고 Stack Protector 가 어떤 원리로 동작하는지 궁금했고 설 연휴를 맞아 자세하게 정리할 수 있었다. 그 과정에서 우분투에 잘못된 버그 리포트 티켓을 만들어내긴 했지만 말이다.
Stack Protection은 GCC의 -fstack-protector, -fstack-protector-all, -fstack-protector-strong 옵션을 통해 활성화할 수 있고 -fno-stack-protector 옵션으로 비활성화 할 수 있다.</description>
    </item>
    
    <item>
      <title>V4L2 Memory Type</title>
      <link>https://seokbeomKim.github.io/posts/v4l2-dmabuf/</link>
      <pubDate>Sun, 18 Apr 2021 00:32:27 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/v4l2-dmabuf/</guid>
      <description>개요 최근 Capture 디바이스 드라이버 코드의 V4L2 표준화 작업을 위해 한 가지 업무를 할당 받았다. 거의 일주일 동안 헤매었는데 다른 선임 개발자가 몇 시간 만에 코드를 수정하니 기대한 결과값이 나오는 것처럼 보였다. 어떻게 동작이 가능했을까 머리로 이해가 되지않아 토요일 하루종일 V4L2 프레임워크와 LWN 을 뒤져가며 프레임워크를 분석하고 나니 왜 그동안 이해가 안됐었는지, 그리고 현재 무엇이 잘못됐는지를 파악할 수 있었다.
본론에 들어가기에 앞서, V4L2 (Video for Linux) 와 Video Buffer 에 대해 간단하게 설명하면, V4L2는 Video Streaming I/O 를 지원하기 위한 프레임워크이다.</description>
    </item>
    
    <item>
      <title>캐시라인(cache-line) 구조 #2</title>
      <link>https://seokbeomKim.github.io/posts/a-structure-of-cacheline/</link>
      <pubDate>Sun, 13 Sep 2020 21:30:10 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/a-structure-of-cacheline/</guid>
      <description>개요 &amp;laquo;코드로 알아보는 ARM 리눅스 커널&amp;raquo;이라는 커널 분석 책으로 스터디를 진행하였다. 예전에 ARM64 아키텍처 부분을 공부한 터라 이해하는 데 문제가 없을 거라 생각했는데 역시나 기억력에 한계가 있었다. 개인적으로는 책의 그림과 내용이 직관적으로 이해가 되지 않고 방해가 방해가 되었다. 나중에 캐시라인의 구조에 대해 분명히 다시 살펴볼 것이므로 아래와 같이 짧게 재 정리해놓고자 한다.
캐시 구조 캐시에 관련된 주요 용어는 아래와 같다.
 태그 캐시라인 인덱스 웨이와 세트  태그 태그는 캐시 탐색 시에 저장되는 메모리 주소의 일부를 만한다.</description>
    </item>
    
    <item>
      <title>캐시 라인(Cache-Line)</title>
      <link>https://seokbeomKim.github.io/posts/cache-line/</link>
      <pubDate>Sat, 25 Apr 2020 14:27:31 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/cache-line/</guid>
      <description>캐시를 꼭 사용해야 하나 SMP 환경에서 일어나는 커널 패닉 문제를 다루다 보면 메모리 배리어를 비롯하여 캐시와 주 메모리 간의 동기화를 다루는 내용이 주를 이룬다. 하지만 매번 간략하게 정리한 문서가 없다보니 기억에 잘 남지도 않고 전체적인 흐름을 읽지 못하는 것 같아 이번 포스팅을 통해서 대략적으로나마 정리하고자 한다.
프로세서 캐시와 메모리의 불일치 문제는 다루기 까다로운 문제이다. 단순하게 프로세서가 싱글 코어라면 문제가 없겠지만 여러 개의 코어를 가지고 있는 프로세서라면 각각의 코어가 가지고 있는 캐시와 주 메모리를 동기화 시켜주어야 한다.</description>
    </item>
    
    <item>
      <title>가상주소와 페이지 테이블 크기</title>
      <link>https://seokbeomKim.github.io/posts/page-table-entry-and-va-bits/</link>
      <pubDate>Sat, 11 Apr 2020 18:25:16 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/page-table-entry-and-va-bits/</guid>
      <description>각 태스트(유저 레벨에서 프로세스라고 일컫는)에는 각각의 가상주소를 갖는다. 사용되는 가상주소는 메모리 상에서 MMU에 의해 물리 메모리로 접근이 가능한데 이 때 MMU에 &amp;lsquo;어떻게 가상 주소를 맵핑할 것인지&amp;rsquo;에 대한 정보를 전달해줘야 한다. 이러한 정보는 &amp;lsquo;페이지 테이블&amp;rsquo;이라는 것으로 표현되어 그 물리주소를 MMU에서 참고하는 레지스터 정보에 저장하게 된다. 포스팅에서 기준으로 삼은 아키텍처는 ARM64이다. ARM64 커널에서는 사용 가능한 페이지의 크기로서 4K, 16K, 64K 등을 사용하고 있고 가상주소 비트 수(VA_BITS)로서 36, 39, 42, 47, 48비트 등을 사용한다.</description>
    </item>
    
    <item>
      <title>DMIPS (Dhrystone Million Instructions Per Second)</title>
      <link>https://seokbeomKim.github.io/posts/dmips/</link>
      <pubDate>Fri, 03 Apr 2020 01:41:29 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/dmips/</guid>
      <description>개요 프로세서의 성능을 나타내는 지표로서 DMIPS라는 것을 사용하게 되었다. 벤치마크로 MIPS만 알고 있었는데 실제로 업무에서 사용했던 것은 DMIPS라는 것이어서 이번에 확실하게 정리하고 가고자 한다.
DMIPS는 드라이스톤(Dhrystone) 벤치마크 테스트의 결과를 정수화해서 이를 하중한 값으로 비교하는 방법으로 프로세서 성능 비교에 이용하는 지표이다. 예를 들어, ARM 32bit Cortex-M3 CPU - 72 MHz maximum frequency 모델의 경우 1.25 DMIS/MHz 인데 여기에 CPU 사용량을 이용하면 해당 프로세서가 가지는 Full DMIPS (72MHz 일 때의 DMIPS) 대비 측정하고자 하는 프로세스에 대한 DMIPS 지표를 얻을 수 있다.</description>
    </item>
    
    <item>
      <title>Little Endian vs. Big Endian</title>
      <link>https://seokbeomKim.github.io/posts/endian/</link>
      <pubDate>Mon, 27 Jan 2020 22:27:06 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/endian/</guid>
      <description>개요 빅 엔디안과 리틀 엔디안에 관해 업무에서 접할 수 있는 상황과 각각에 해당하는 포인터 연산 예제를 종합적으로 정리하도록 한다.
엔디안(Endianness)은 컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻하며, 바이트를 배열하는 방법을 바이트 순서(Byte-order)라고 한다. 엔디안은 보통 큰 단위가 앞에 나오는 빅 엔디안(Big-Endian)과 작은 단위가 앞에 나오는 리틀 엔디안(Little-Endian)으로 나눌 수 있으며, 두 경우에 속하지 않거나 둘 모두 지원하는 것을 미들 엔디안(Middle-Endian)이라 부른다.
 Big-Endian: 최상위 바이트(MSB)부터 차례로 저장하는 방식 (사람이 읽고 쓰는 방식과 비슷함) Little-Endian: 최하위 바이트(LSB)부터 차례로 저장하는 방식  예제 예를 들어, 메모리에 0x12345678을 대입한다고 했을 때, 빅 엔디안과 리틀 엔디안 각각 아래와 같이 저장된다.</description>
    </item>
    
    <item>
      <title>영상 출력 포맷</title>
      <link>https://seokbeomKim.github.io/posts/digital_output_formats/</link>
      <pubDate>Sun, 26 Jan 2020 17:44:18 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/digital_output_formats/</guid>
      <description>디지널 출력 포맷 아날로그 신호에 대한 디지털 포맷으로서 표준화된 포맷들을 기술한다. 대표적인 표준으로는 BT.601, BT.656 이 있으며 그 외에도 최근에는 BT.2020 등의 고화질 영상을 타겟으로 한 표준들이 나오고 있다. 디지털 텔레비전의 부호화 파라미터들을 정의한 권고안으로서 601은 모든 컴포넌트 디지털 영상 표준에 대한 기초가 되었다.
규격 내용 각 표준에는 아래와 같은 내용들을 정의한다.
 화면비 휘도 및 색 신호에 대한 처리 영상 포맷 형식 기준 주파수 샘플링 주파수 샘플링 및 코딩 형식  BT.</description>
    </item>
    
    <item>
      <title>색 공간(Color Space)</title>
      <link>https://seokbeomKim.github.io/posts/color-space/</link>
      <pubDate>Sun, 26 Jan 2020 16:39:36 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/color-space/</guid>
      <description>색 공간 포맷 업무 상에 사용되는 일반적인 색 인코딩 시스템은 RGB 와 YUV 이다. 그 중에서도 SoC의 각 컴포넌트에서 이미지 처리를 위해 기본으로 요구하는 포맷은 YUV 이다. YUV에는 서브샘플링 방법에 따라 YUV444, YUV422, YUV411, YUV420 등으로 세분화할 수 있는데 각 특징에 따라 실제 표현되는 색이 달라지므로 주의해야 한다.
색 포맷에 대한 비트 구성은 표준에 따르지 않고 각 플랫폼 환경에 따라 달라지므로 SoC 데이터시트를 참고하여 컴포넌트에서 어떻게 구성되는지 확인해야 한다.
RGB RGB의 대표적인 포맷으로는 ARGB8888, RGB888 등이 있다.</description>
    </item>
    
    <item>
      <title>부트로더(Bootloader)</title>
      <link>https://seokbeomKim.github.io/posts/bootloader/</link>
      <pubDate>Sun, 23 Jun 2019 22:47:44 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/bootloader/</guid>
      <description>이 포스팅의 내용은 임베디드 리눅스에서의 부트로더 역할에 대해 중점적으로 다룬다. 부트로더는 시스템을 초기화하고 임베디드 운영체제를 탑재하거나 실행하기 위해서 시스템 초기화 코드, 하드웨어 제어 프로그램, 네트워크, USB 등의 프로토콜과 일부 파일 시스템을 관리한다.
브투로더는 개인용 컴퓨터의 BIOS(Basic Input Output System)와 유사하다고 생각하면 된다. BIOS는 처음 전원을 공급하면 메인보드의 CMOS에 저장된 설정값을 읽어서 하드웨어를 초기화하고 그래픽 카드 정보 및 바이오스 정보를 출력한 다음 POST(Power-On Self Test) 과정을 수행하고 하드디스크나 CD-ROM 또는 플로피디스크에서 운영체제를 찾아 부팅한다.</description>
    </item>
    
    <item>
      <title>RCU (Read, Copy, Update)</title>
      <link>https://seokbeomKim.github.io/posts/rcu/</link>
      <pubDate>Tue, 04 Jun 2019 17:34:42 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/rcu/</guid>
      <description>1. 들어가기 전에 &amp;hellip; 앞으로 기술하는 내용은 http://jake.dothome.co.kr/rcu/#comment-214230 에서 발췌하여 정리하는 내용이므로 원본 내용 확인을 위해서는 링크에서 직접 보길 권한다. RCU 내용 뿐만 아니라, 리눅스 커널 전반적인 내용에 대해 정말 자세하게 정리가 잘 되어있다.
RCU(Read, Copy, Update)란 리눅스 커널 내에서 주로 읽기 연산만 일어나고 쓰기 연산의 비중은 매우 작은 객체에 주로 쓰이는 동기화 기법이다. Reader-Writer 락과 비슷한 동기화 기법인데, RW 락에 대해 RCU가 가지는 상대적인 강점으로는 읽기 연산이 wait-free(읽기 연산에 대해 Block이 일어나지 않음)이며 그 오버헤드가 극도로 작다는 점 등이 있다.</description>
    </item>
    
    <item>
      <title>리눅스 커널 락 종류 (4/5)</title>
      <link>https://seokbeomKim.github.io/posts/locks-in-the-kernel-4/</link>
      <pubDate>Tue, 04 Jun 2019 16:40:28 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/locks-in-the-kernel-4/</guid>
      <description>BKL(Big Kernel Lock)은 커널 2.0에서 SMP와 함께 소개된 락으로서 Giant-Lock, Big-Lock 또는 Kernel-Lock 으로 알려졌었다. 2.0 버전의 커널에서는 한 번에 하나의 스레드만이 커널 모드에서 동작하기 위해 락(Lock)을 획득해야 커널 모드로 진입되었고 나머지 프로세서들은 락을 획득하기 위해 대기한다. 하지만 이 후, 성능, 실시간 애플리케이션에 대한 latency 이슈로 BKL(Big Kernel Lock)은 스핀락과 뮤텍스, RCU 등으로 대체되면서 현재는 거의 관련 코드가 제거되어 있는 상태이다.
 lock_kernel(): Acquires the BKL unlock_kernel(): Releases the BKL kernel_locked(): Returns nonzero if the lock is held and zero otherwise (UP always returns nonzero)  BKL은 프로세서들이 동시에 커널에 진입하는 것을 막아 동기화 문제를 해결한다.</description>
    </item>
    
    <item>
      <title>리눅스 커널 락 종류 (3/5)</title>
      <link>https://seokbeomKim.github.io/posts/locks-in-the-kernel-3/</link>
      <pubDate>Tue, 04 Jun 2019 11:40:12 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/locks-in-the-kernel-3/</guid>
      <description>이번 포스팅에서는 리눅스 커널 락의 세 번째인 세마포어에 대해 기술한다. 리눅스의 세마포어(semaphore)는 휴면하는 락이라고 생각하면 된다. 태스크가 이미 사용 중인 세마포어를 얻으려고 하면, 세마포어는 해당 태스크를 대기큐에 넣고 휴면 상태로 만든다. 그 다음 프로세서는 자유롭게 다른 코드를 실행한다. 세마포어가 다시 사용 가능해지면 대기큐의 태스크 하나를 깨우고 이 태스크가 세마포어를 사용하게 된다.
세마포어는 아래와 같은 경우에 적합하다.
태스크, 즉 프로세스의 상태는 TASK_RUNNING, TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE 로 나눌 수 있으며, 이 중 TASK_INTERRUPTIBLE 상태가 프로세스가 휴면에 진입한 상태로 프로세스를 깨우면 다시 TASK_RUNNING(실행 대기) 상태로 변경된다.</description>
    </item>
    
    <item>
      <title>리눅스 커널 락 종류 (2/5)</title>
      <link>https://seokbeomKim.github.io/posts/locks-in-the-kernel-2/</link>
      <pubDate>Wed, 29 May 2019 00:59:34 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/locks-in-the-kernel-2/</guid>
      <description>지난 번 포스팅에서는 리눅스 커널 락 중 하나인 스핀락(Spinlock)에 대해 기술하였다. 이번 포스팅에서는 뮤텍스(Mutex)에 대해서 기술하고자 한다. 많은 곳에서 뮤텍스는 세마포어의 카운트 값이 단순하게 1로 설정되었을 때를 말한다고 기술한다. 하지만 이것이 맞는 설명일까?
참고 자료에 따르면 뮤텍스는 공유 자원으로의 접근(Access)에 대한 상호 배제(Mutual Exclusion)을 위한 수단이 Mutex라고 정의하고 있다. 이에 반해 세마포어(Semaphore)는 시그널 매커니즘으로서 스레드(또는 프로세스) 간 동기화가 주 목적으로, wait 함수를 호출한 스레드만이 뮤텍스를 신호를 보낼 수 있다는 점이 기능적인 특징이다.</description>
    </item>
    
    <item>
      <title>리눅스 커널 락 종류 (1/5)</title>
      <link>https://seokbeomKim.github.io/posts/locks-in-the-kernel-1/</link>
      <pubDate>Tue, 28 May 2019 17:45:51 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/locks-in-the-kernel-1/</guid>
      <description>&lt;p&gt;리눅스 커널에서 사용되는 락의 종류는 다양하다. 학부 시절, &lt;em&gt;&amp;lsquo;뮤텍스는
세마 포어의 카운트가 1인 락&amp;rsquo;이라는 말도 안되는 내용으로 학교
선배로부터 배웠던 것이 기억난다.&lt;/em&gt; 락의 종류별로 쓰임새가 있고 장단점이
있는 것인데, 이 문서에는 커널에서 사용하는 락(lock)의 종류와 각각에
대한 사용 예를 기술하고자 한다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>지피(Jiffies)</title>
      <link>https://seokbeomKim.github.io/posts/jiffies/</link>
      <pubDate>Sun, 26 May 2019 10:38:40 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/jiffies/</guid>
      <description>오랜만에 지피에 대한 포스팅을 다시 작성한다(대학생 때 커널 공부를 한 뒤로 이렇게 별도로 문서를 작성하는 것은 처음인 것 같다). 전역 변수인 jiffies에는 시스템 시작 이후 발생한 진동 횟수(tick)이 저장된다. 시스템 시작 시 커널은 이 값을 0으로 설정하고 타이머 인터럽트가 발생할 때마다 1씩 증가시킨다. 타이머 인터럽트는 초당 HZ회 발생하므로, 초당 지피 수는 HZ가 되며, 이에 따라 시스템 가동 시간은 jiffies / HZ(초)가 된다.
커널은 버그 식별을 위해 jiffies 변수의 오버플로우 현상이 자주 일어나기 위해 jiffies 변수를 0이 아닌 특별한 값으로 초기화하며 실제 jiffies값이 필요한 경우에는 이 차이(offset)값을 빼야 한다.</description>
    </item>
    
    <item>
      <title>OSI 7-Layers</title>
      <link>https://seokbeomKim.github.io/posts/osi-7-layers/</link>
      <pubDate>Tue, 21 May 2019 16:10:20 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/osi-7-layers/</guid>
      <description>네트워크의 기본 개념인 OSI 7-Layers에 대해서 정리하고자 한다. 학부 시절 달달 외우기만 했던 까닭에 제대로 공부하지 못해 아쉬웠던 7계층 개념인데 외우기보다 이해하는 것이 훨씬 간단하므로, 필자의 경험을 이용해 (나중에 기억하기 쉽도록) 정리하고자 한다.
OSI 7계층에 대해 설명하기 위해 이 역시 방산업체에서의 경험을 이용하고자 한다. 아래는 OSI 7계층을 나타낸 그림이다. 이 때, 각 레이어들을 데이터들이 송수신될 때 전달되는 경로로 생각하며 그림을 이해해야 한다.L1. 물리 계층, Physical Layer 물리 계층은 말 그대로 네트워크 장비들 간에 데이터를 송수신하기 위해 물리적으로 신호를 주고받는 계층이다.</description>
    </item>
    
    <item>
      <title>커널 해킹: 프로세스</title>
      <link>https://seokbeomKim.github.io/posts/kernel-hacking-chapter-process/</link>
      <pubDate>Thu, 16 May 2019 18:59:15 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/kernel-hacking-chapter-process/</guid>
      <description>앞으로 리눅스 커널 공부를 해가면서 포스팅으로 정리해둘 계획이다. 디바이스 드라이버 개발 이전에 리눅스라는 운영체제에 대해 개인적으로 정리해야할 필요성을 느꼈다. 그리고 최신 커널을 사용하기 보다 상대적으로 오래된 커널을 시작으로 공부하고자 한다. 기본 틀은 크게 변하지 않았을거라 생각하고 충분히 이해한 뒤에 최근 버전을 받아 개발 흐름을 이해하는 것이 옳은 방법이라 생각하였다.
이 문서에서는 리눅스/유닉스 운영체제의 기본 추상화 개념 중 하나인 프로세스에 대해 정리하고자 한다. 정리에 필요한 정보 수집을 위해서 Linux kernel development(3rd edition) 책과 LWN 등의 사이트들을 참고한다.</description>
    </item>
    
    <item>
      <title>Copy on Write (CoW or COW)</title>
      <link>https://seokbeomKim.github.io/posts/copy-on-write/</link>
      <pubDate>Thu, 16 May 2019 18:24:16 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/copy-on-write/</guid>
      <description>Copy-on-write은 리눅스 커널의 fork() 함수에서 사용하는 기법이다.
전통적인 fork()는 부모 프로세스의 모든 자원을 복사해 자식 프로세스에게 넘겨준다. 하지만 이러한 방식은 공유가 가능한 많은 데이터를 복사하므로 단순하고 비효율적이다. 게다가 새로 만든 프로세스가 곧바로 다른 프로그램을 실행한다면 복사 작업이 모두 헛수고가 되고 만다.
이러한 문제를 해결하기 위해 리눅스에서는 Copy-on-write, COW 기법을 이용하는데 기록사항 발생 시에 복사하는 기능으로 즉각적인 데이터의 복사를 지연하거나 방지하는 기법이다. 때문에 fork()를 사용하게 되면 프로세스의 주소 공간을 모두 복사하는 대신, 부모와 자식 프로세스가 같은 공간을 공유하고 있다가 기록 사항이 발생했을 때 사본을 만든다.</description>
    </item>
    
    <item>
      <title>교착상태(Deadlock)</title>
      <link>https://seokbeomKim.github.io/posts/deadlock/</link>
      <pubDate>Wed, 15 May 2019 17:40:14 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/deadlock/</guid>
      <description>교착 상태(Deadlock) 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 아무 것도 완료되지 않는 상태를 가리킨다. 이 문제를 해결하는 일반적인 방법은 아직 없는 상태다.
교착 상태는 하나의 사다리에 두 명이 사람이 매달려 있는 상황을 예상할 수 있다. 위쪽의 사람은 아래로 내려오려고 하고 아래에 있는 사람은 위로 올라가려고 한다면 서로 상대방이 사다리에서 비켜줄 때까지 계속 기다리고 있을 것이고 결과적으로 아무도 사다리에서 내려오거나 올라가지 못하듯이 교착 상태란 다중 프로그래밍 환경에서 흔히 발생할 수 있는 문제이다.</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>web on A Developer&#39;s Note</title>
    <link>https://seokbeomKim.github.io/categories/web/</link>
    <description>Recent content in web on A Developer&#39;s Note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 May 2019 15:27:08 +0900</lastBuildDate>
    
	<atom:link href="https://seokbeomKim.github.io/categories/web/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>TCP와 UDP의 차이점</title>
      <link>https://seokbeomKim.github.io/posts/tcp-and-udp/</link>
      <pubDate>Tue, 21 May 2019 15:27:08 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/tcp-and-udp/</guid>
      <description>예전에 TCP, UDP에 대해서 정리해놓은 것들을 찾을 수 없어 블로그 페이지로 정리하고자 포스팅을 새로 만들었다. 앞으로 두고두고 찾아보게 될 페이지므로 향후 커널 소스 분석을 통해 TCP, UDP와 관련된 부분이 나올 경우 포스팅을 업데이트 할 예정이다.
방산 업체에서 무인 정찰기를 개발할 당시에도 중요 데이터는 모두 TCP를 이용해 송수신하고 영상과 같은 정보는 UDP를 이용해 전달받았다. 당시에 구현된 코드를 보면서 이전에 프로토콜 사용에 있어서 어디부터 어디까지를 UDP 혹은 TCP로 해야 하는가에 대해 논란이 있었을거라 예상했지만 코드를 변경할 수 없어 아쉬웠던 적이 있었다.</description>
    </item>
    
    <item>
      <title>서블릿 컨테이너와 서버와의 관계</title>
      <link>https://seokbeomKim.github.io/posts/servlet-container/</link>
      <pubDate>Fri, 03 May 2019 17:50:32 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/servlet-container/</guid>
      <description>개요 아파치 서버에 톰캣(tomcat)을 이용하여 젠킨스와 같은 애플리케이션을 올려본 적은 있어도 직접 서블릿 컨테이너에서 사용할 수 있는 애플리케이션은 개발해 본 적이 없다. 때문에 서블릿이라는 용어 자체가 생소하고 웹 서버에서 이를 어떻게 관리하는지에 대해 궁금한 점을 중점으로 정리하고자 한다.
정리하고자 하는 질문은 아래와 같다.
 Apache나 Nginx에서 서블릿 컨테이너로 어떤 방식을 통해서 클라이언트 요청을 넘겨주는가? 서블릿 컨테이너가 만들어진 이유는 무엇인가? 애플리케이션의 서블릿은 서블릿 컨테이너가 가지고 있는 라이프사이클 중 언제 추가되는가? 애플리케이션이 가지는 서블릿은 서블릿 컨테이너에 어떤 형태로 추가되는가?</description>
    </item>
    
    <item>
      <title>파티셔닝(Partitioning)과 샤딩(Sharding)</title>
      <link>https://seokbeomKim.github.io/posts/partition-and-sharding/</link>
      <pubDate>Wed, 01 May 2019 20:29:02 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/partition-and-sharding/</guid>
      <description>개요 데이터베이스에 관련된 문서를 보다보니 Partition, Sharding이라는 용어들이 등장하기 시작하기 시작했다. 이러한 것들은 말 그 대로 데이터베이스를 여러 개로 나누어 분산시키기 위한 기술 용어들인데 모두 서비스 크기 증가에 따른 DB 크기 증가, 성능 이슈에 따른 것이다. 일명 VLDB(Very Large DBMS)라 불리는, DBMS 하나로 전체 데이터베이스를 다룰 수 없는 데이터베이스가 자연스럽게 등장하였고 DBMS 한 개가 여러 개의 테이블을 관리하면서 성능 이슈도 생기게 되었는데 이를 해결하기 위한 것이 바로 파티셔닝(partitioning) 과 샤딩(Sharding)이다.</description>
    </item>
    
    <item>
      <title>RESTful 성숙도 모델, Richardson Maturity Model(RMM)</title>
      <link>https://seokbeomKim.github.io/posts/rest-api-model/</link>
      <pubDate>Wed, 01 May 2019 18:38:22 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/rest-api-model/</guid>
      <description>개요 이 문서는 진행하는 프로젝트에서 백엔드 서버에서 제공할 REST API를 어떻게 설계해야 하는가에 대해 공부하던 중 인터넷에서 찾은 문서를 정리한 것이다. 이 문서에서는 REST 소개부터 API 설계 방법, 그리고 설계한 API가 &amp;lsquo;RESTful&amp;rsquo; 이라는 형용사를 붙일 수 있는지 판단할 수 있는 &amp;lsquo;Richardson Maturity Model&#39;이라는 성숙도 모델을 기술한다.
REST 소개 이 절은 Microsoft의 REST 소개를 발췌하여 정리한 것이다.
REST는 하이퍼미디어 기반 분산 시스템을 구축하기 위한 아키텍처 스타일로서 프로토콜과는 관련이 없는 용어이다. (일각에서 REST와 SOAP를 비교하는 글들이 많아 언급하였다.</description>
    </item>
    
    <item>
      <title>HTTP/1.1과 HTTP/2의 차이점</title>
      <link>https://seokbeomKim.github.io/posts/http1-http2/</link>
      <pubDate>Wed, 01 May 2019 17:29:25 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/http1-http2/</guid>
      <description>HTTP/1.1 vs HTTP/2 HTTP 프로토콜에 대해서는 관심이 없다가 문득 텔레그램의 봇을 통해 우연히 HTTP/2의 개념을 처음으로 접하게 되었다. 이 문서는 HTTP/1.1과 HTTP/2 의 차이점을 설명하고 1.1에서 2로 변화하면서 어떻게 개선되었는지 기술한다.
HTTP/1.1 동작 방식 HTTP(HyperText Transfer Protocol)은 웹에서 클라이언트(웹 브라우저)가 웹 서버(httpd, nginx, etc&amp;hellip;)와 통신하기 위한 프로토콜 중 하나이다. HTTP 1.1은 클라이언트와 서버 간의 통신을 위해 다음과 같은 과정을 거친다.
위 그림에서 알 수 있듯이 HTTP/1.1은 기본적으로 Connection 한 개당 하나의 요청을 처리하도록 설계되어 있다.</description>
    </item>
    
    <item>
      <title>CORS(Cross-Origin Resource Sharing)</title>
      <link>https://seokbeomKim.github.io/posts/cors/</link>
      <pubDate>Wed, 01 May 2019 17:20:49 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/cors/</guid>
      <description>CORS(Cross-Origin Resource Sharing) 웹 보안 정책 중 Same-Origin Policy는 한 출처(Origin)에서 로드된 문서나 스크립트가 다른 출처 자원과 상호작용하지 못하도록 제약한다. 언급한 출처(Origin)는 두 페이지의 프로토콜, 호스트, 포트가 같으면 동일 출처로 간주한다.
하지만 이러한 보안 정책으로 인해 타 사이트로부터 받아오는 리소스나 웹 폰트, CDN 등의 사용에 문제가 되고 있어 CORS(Cross-Origin Resource Sharing)이라는 추가 정책이 나오게 되었다.
CORS 요청 CORS 요청에는 Simple/Preflight, Credential/Non-Credential의 조합으로 총 4가지 요청이 존재한다. 브라우저가 요청 내용을 분석하여 4가지 방식 중 해당하는 방식으로 서버에 요청을 날리므로 프로그래머가 목적에 맞는 방식을 선택해 그 조건에 맞게 코딩해야 한다.</description>
    </item>
    
    <item>
      <title>컨텐츠 전송 네트워크, CDN(Content Delivery Network)</title>
      <link>https://seokbeomKim.github.io/posts/cdn/</link>
      <pubDate>Wed, 01 May 2019 17:19:18 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/cdn/</guid>
      <description>CDN(Content Delivery Network) Content Delivery Network 또는 Content Distribution Network라고 불리는 네트워크는 컨텐츠를 효율적으로 전달하기 위해 여러 노드를 가진 네트워크에 데이터를 저장하여 제공하는 시스템을 말한다. 관련된 질문으로는 &amp;lsquo;CDN vs. Cache, 무엇이 더 효율적인가?&amp;lsquo;라는 것이 있다. CDN은 오늘날 텐스트, 그래픽, 스크립트, 미디어 파일, 소프트웨어, 문서 등의 다운로드가 가능한 객체들 뿐만 아니라 어플리케이션, 라이브 스트리밍 미디어 등의 다양한 컨텐츠들을 망라하여 제공하고 있다.
아래의 그림을 살펴보자.
왼쪽의 그림은 컨텐츠가 End User들에게 직접 제공되는 반면에 오른쪽 그림은 End-User에서 가장 가까운 CDN 서버를 통해 간접적으로 전달된다.</description>
    </item>
    
    <item>
      <title>가상호스트(Virtual Host)와 Host Header</title>
      <link>https://seokbeomKim.github.io/posts/vhost-host-header/</link>
      <pubDate>Wed, 01 May 2019 17:16:40 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/vhost-host-header/</guid>
      <description>Virtual Host and Host Header 문득 HTTP/2에 대한 책을 읽다가 가상호스트(Virtual host)와 호스트 헤더(Host header)에 대한 얘기가 나왔다. 대체 가상 호스트와 호스트 헤더 간에는 무슨 관계가 있는 것일까. 이 문서에서는 가상 호스트와 가상호스트 종류, 그리고 마지막으로 호스트 헤더와 어떤 식으로 연관되는지에 대해 설명하겠다.
가상 호스트(Virtual Host) 가상호스트란 싱글 서버(또는 서버 풀)에서 여러 개의 도메인 이름으로 호스팅하기 위한 방법이다. 가상 호스트를 사용함으로써 얻는 이점은 하나의 서버로 해당 서버의 리소스(메모리, 프로세서 사이클 등)를 공유할 수 있다는 점이다.</description>
    </item>
    
    <item>
      <title>Server Name Indication(SNI)</title>
      <link>https://seokbeomKim.github.io/posts/sni/</link>
      <pubDate>Wed, 01 May 2019 17:12:34 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/sni/</guid>
      <description>Server Name Indication Server Name Indication(줄여서 SNI)는 SSL/TLS 기반의 HTTPS에 기반한 Name-based 가상 호스팅 환경에서 일어날 수 있는 문제점을 해결하기 위해 구현된 HTTPS의 Extension이다. 해당 문제점에 대해 구체적으로 설명하자면 Name-based 가상 호스팅 환경에서 클라이언트는 서버로 어떤 vhost를 사용할 것인지 Request 메시지에 같이 보낸다. 이 때, 사용하는 프로토콜이 HTTP가 아닌 HTTPS라면 서버는 클라이언트로 Server Hello 패킷을 보낼 때 패킷 내에 인증서 데이터를 함께 전송한다. 클라이언트가 다시 서버로 Client Hello를 보낼 때 클라이언트는 서버에서 보내준 인증서의 공개키로 암호화하여 패킷을 보내게 되는데 서버 입장에서는 클라이언트가 사용한 인증서가 어떤 가상 호스트에서 보낸 인증서인지 알 길이 없다.</description>
    </item>
    
    <item>
      <title>HTTP와 HTTPS의 차이점</title>
      <link>https://seokbeomKim.github.io/posts/diff_http_https/</link>
      <pubDate>Wed, 01 May 2019 16:53:27 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/diff_http_https/</guid>
      <description>HTTP와 HTTPS의 차이점 HTTP와 HTTPS의 차이점은 그 용어에서부터 단번에 알아챌 수 있다. 바로 끝 글자 &amp;lsquo;S&#39;가 나타내는 Secure라는 의미로부터 HTTP에 &amp;lsquo;어떤 것&#39;을 추가하여 보안을 강화한 프로토콜이라는 것을 짐작할 수 있다. 여기서 중요한 것은 HTTP에 추가한&#39;어떤 것&#39;인데 이 것이 바로 TLS(SSL라고도 부름)가 되겠다. HTTPS를 이해하기 위해서는 TLS에 대해 알아야 하므로 이 문서에서는 TLS에 대한 기본적인 개념과 HTTPS가 등장하게 된 배경에 대한 설명으로 HTTP와 HTTPS의 차이점을 설명하도록 하겠다. 먼저, HTTP, HTTPS와 TLS 프로토콜부터 살펴보자.</description>
    </item>
    
  </channel>
</rss>
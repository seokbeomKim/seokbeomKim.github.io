<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on A Developer&#39;s Note</title>
    <link>https://seokbeomKim.github.io/categories/linux/</link>
    <description>Recent content in Linux on A Developer&#39;s Note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Jan 2020 22:25:50 +0900</lastBuildDate>
    
	<atom:link href="https://seokbeomKim.github.io/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kobject</title>
      <link>https://seokbeomKim.github.io/posts/kobject/</link>
      <pubDate>Tue, 28 Jan 2020 22:25:50 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/kobject/</guid>
      <description>디바이스 트리를 살펴보다 kobject 에 대한 내용이 언급되기 시작했다. 단순한 객체가 아니라 특수한 목적으로 사용될 것이라 예상되어 관련 내용을 찾아보았다.
61 struct kobject { 62 const char *name; 63 struct list_head entry; 64 struct kobject *parent; 65 struct kset *kset; 66 struct kobj_type *ktype; 67 struct kernfs_node *sd; 68 struct kref kref; 69 #ifdef CONFIG_DEBUG_KOBJECT_RELEASE 70 struct delayed_work release; 71 #endif 72 unsigned int state_initialized:1; 73 unsigned int state_in_sysfs:1; 74 unsigned int state_add_uevent_sent:1; 75 unsigned int state_remove_uevent_sent:1; 76 unsigned int uevent_suppress:1; 77 }; 커널 문서(https://www.</description>
    </item>
    
    <item>
      <title>RCU (Read, Copy, Update)</title>
      <link>https://seokbeomKim.github.io/posts/rcu/</link>
      <pubDate>Tue, 04 Jun 2019 17:34:42 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/rcu/</guid>
      <description>1. 들어가기 전에 &amp;hellip; 앞으로 기술하는 내용은 http://jake.dothome.co.kr/rcu/#comment-214230 에서 발췌하여 정리하는 내용이므로 원본 내용 확인을 위해서는 링크에서 직접 보길 권한다. RCU 내용 뿐만 아니라, 리눅스 커널 전반적인 내용에 대해 정말 자세하게 정리가 잘 되어있다.
RCU(Read, Copy, Update)란 리눅스 커널 내에서 주로 읽기 연산만 일어나고 쓰기 연산의 비중은 매우 작은 객체에 주로 쓰이는 동기화 기법이다. Reader-Writer 락과 비슷한 동기화 기법인데, RW 락에 대해 RCU가 가지는 상대적인 강점으로는 읽기 연산이 wait-free(읽기 연산에 대해 Block이 일어나지 않음)이며 그 오버헤드가 극도로 작다는 점 등이 있다.</description>
    </item>
    
    <item>
      <title>리눅스 커널 락 종류 (4/5)</title>
      <link>https://seokbeomKim.github.io/posts/locks-in-the-kernel-4/</link>
      <pubDate>Tue, 04 Jun 2019 16:40:28 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/locks-in-the-kernel-4/</guid>
      <description>BKL(Big Kernel Lock)은 커널 2.0에서 SMP와 함께 소개된 락으로서 Giant-Lock, Big-Lock 또는 Kernel-Lock 으로 알려졌었다. 2.0 버전의 커널에서는 한 번에 하나의 스레드만이 커널 모드에서 동작하기 위해 락(Lock)을 획득해야 커널 모드로 진입되었고 나머지 프로세서들은 락을 획득하기 위해 대기한다. 하지만 이 후, 성능, 실시간 애플리케이션에 대한 latency 이슈로 BKL(Big Kernel Lock)은 스핀락과 뮤텍스, RCU 등으로 대체되면서 현재는 거의 관련 코드가 제거되어 있는 상태이다.
 lock_kernel(): Acquires the BKL unlock_kernel(): Releases the BKL kernel_locked(): Returns nonzero if the lock is held and zero otherwise (UP always returns nonzero)  BKL은 프로세서들이 동시에 커널에 진입하는 것을 막아 동기화 문제를 해결한다.</description>
    </item>
    
    <item>
      <title>리눅스 커널 락 종류 (3/5)</title>
      <link>https://seokbeomKim.github.io/posts/locks-in-the-kernel-3/</link>
      <pubDate>Tue, 04 Jun 2019 11:40:12 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/locks-in-the-kernel-3/</guid>
      <description>이번 포스팅에서는 리눅스 커널 락의 세 번째인 세마포어에 대해 기술한다. 리눅스의 세마포어(semaphore)는 휴면하는 락이라고 생각하면 된다. 태스크가 이미 사용 중인 세마포어를 얻으려고 하면, 세마포어는 해당 태스크를 대기큐에 넣고 휴면 상태로 만든다. 그 다음 프로세서는 자유롭게 다른 코드를 실행한다. 세마포어가 다시 사용 가능해지면 대기큐의 태스크 하나를 깨우고 이 태스크가 세마포어를 사용하게 된다.
세마포어는 아래와 같은 경우에 적합하다.
태스크, 즉 프로세스의 상태는 TASK_RUNNING, TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE 로 나눌 수 있으며, 이 중 TASK_INTERRUPTIBLE 상태가 프로세스가 휴면에 진입한 상태로 프로세스를 깨우면 다시 TASK_RUNNING(실행 대기) 상태로 변경된다.</description>
    </item>
    
    <item>
      <title>Major와 Minor Numbers</title>
      <link>https://seokbeomKim.github.io/posts/major-and-minor-numbers/</link>
      <pubDate>Fri, 31 May 2019 18:37:25 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/major-and-minor-numbers/</guid>
      <description>세마포어를 이용한 모듈 프로그래밍을 하던 중 Major, Minor 라는 개념이 등장하였다. 인터넷으로 찾은 커널 모듈 소스가 구버전 커널을 기준으로 한 까닭에, 커널 코드가 어떻게 변경되어 갔는지 히스토리를 삽질해 볼 수 있는 아주 좋은 기회다.
캐릭터 디바이스는 /dev 디렉토리에서 쉽게 확인할 수 있는데 파일의 속성에서 각 장치에 대한 속성은 맨 앞 문자를 통해 판단할 수 있다. 예를 들어, &amp;lsquo;c&#39;를 포함하고 있다면 캐릭터 디바이스(character devices)를 위한 특수 파일로, &amp;lsquo;b&#39;를 포함하고 있다면 블록 디바이스(block devices)로 식별할 수 있다.</description>
    </item>
    
    <item>
      <title>리눅스 커널 락 종류 (2/5)</title>
      <link>https://seokbeomKim.github.io/posts/locks-in-the-kernel-2/</link>
      <pubDate>Wed, 29 May 2019 00:59:34 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/locks-in-the-kernel-2/</guid>
      <description>지난 번 포스팅에서는 리눅스 커널 락 중 하나인 스핀락(Spinlock)에 대해 기술하였다. 이번 포스팅에서는 뮤텍스(Mutex)에 대해서 기술하고자 한다. 많은 곳에서 뮤텍스는 세마포어의 카운트 값이 단순하게 1로 설정되었을 때를 말한다고 기술한다. 하지만 이것이 맞는 설명일까?
참고 자료에 따르면 뮤텍스는 공유 자원으로의 접근(Access)에 대한 상호 배제(Mutual Exclusion)을 위한 수단이 Mutex라고 정의하고 있다. 이에 반해 세마포어(Semaphore)는 시그널 매커니즘으로서 스레드(또는 프로세스) 간 동기화가 주 목적으로, wait 함수를 호출한 스레드만이 뮤텍스를 신호를 보낼 수 있다는 점이 기능적인 특징이다.</description>
    </item>
    
    <item>
      <title>리눅스 커널 락 종류 (1/5)</title>
      <link>https://seokbeomKim.github.io/posts/locks-in-the-kernel-1/</link>
      <pubDate>Tue, 28 May 2019 17:45:51 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/locks-in-the-kernel-1/</guid>
      <description>&lt;p&gt;리눅스 커널에서 사용되는 락의 종류는 다양하다. 학부 시절, &lt;em&gt;&amp;lsquo;뮤텍스는
세마 포어의 카운트가 1인 락&#39;이라는 말도 안되는 내용으로 학교
선배로부터 배웠던 것이 기억난다.&lt;/em&gt; 락의 종류별로 쓰임새가 있고 장단점이
있는 것인데, 이 문서에는 커널에서 사용하는 락(lock)의 종류와 각각에
대한 사용 예를 기술하고자 한다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>지피(Jiffies)</title>
      <link>https://seokbeomKim.github.io/posts/jiffies/</link>
      <pubDate>Sun, 26 May 2019 10:38:40 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/jiffies/</guid>
      <description>오랜만에 지피에 대한 포스팅을 다시 작성한다(대학생 때 커널 공부를 한 뒤로 이렇게 별도로 문서를 작성하는 것은 처음인 것 같다). 전역 변수인 jiffies에는 시스템 시작 이후 발생한 진동 횟수(tick)이 저장된다. 시스템 시작 시 커널은 이 값을 0으로 설정하고 타이머 인터럽트가 발생할 때마다 1씩 증가시킨다. 타이머 인터럽트는 초당 HZ회 발생하므로, 초당 지피 수는 HZ가 되며, 이에 따라 시스템 가동 시간은 jiffies / HZ(초)가 된다.
커널은 버그 식별을 위해 jiffies 변수의 오버플로우 현상이 자주 일어나기 위해 jiffies 변수를 0이 아닌 특별한 값으로 초기화하며 실제 jiffies값이 필요한 경우에는 이 차이(offset)값을 빼야 한다.</description>
    </item>
    
    <item>
      <title>태스크릿(Tasklet)</title>
      <link>https://seokbeomKim.github.io/posts/tasklet/</link>
      <pubDate>Sat, 25 May 2019 17:32:26 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/tasklet/</guid>
      <description>커널 모듈 프로그래밍을 연습하던 도중, 태스크릿 예제를 접하게 되었다. 한참 전에 태스크릿이 어떤 것인지 이론으로 접하기는 했으나 직접 사용해본 적은 없었기 때문에 이 문서를 통해 정리하고자 한다.
간단히 말해 tasklet은 스택이나 자체 컨텍스트가 없는 스레드와 같은 것으로 설명하고 있다.
태스크릿(Tasklet)의 특성  태스크릿(tasklet)은 원자성을 가지고 있기 때문에 mutex, semaphore와 같은 동기화 수단을 사용하거나 sleep() 을 사용할 수 없다. 단, spinlock은 가능하다. ISR보다 유연한 컨텍스트(softer context)로 불린다. 때문에 태스크릿의 컨텍스트 도중 하드웨어 인터럽트가 발생하는 것을 허용한다.</description>
    </item>
    
    <item>
      <title>커널 모듈과 드라이버의 차이</title>
      <link>https://seokbeomKim.github.io/posts/kernel-module-and-drivers/</link>
      <pubDate>Thu, 16 May 2019 02:11:40 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/kernel-module-and-drivers/</guid>
      <description>오랜만에 커널 공부를 다시 시작하면서 소스 트리를 다시 살펴보게 되었다. 분명히 예전에도 같은 질문을 가졌겠거니 생각하면서 트리를 보고 난 후의 첫 질문을 정리하고자 한다.
커널 디렉토리 구조는 대략 다음과 같이 구성되며, 그 중 drivers와 modules의 차이점이 이해하기가 어려웠다.
arch/ - 특정 아키텍처에 국한된 코드 include/ - 커널 빌드를 위해 포함하는 include 파일들 init/ - 커널 초기화 코드 mm/ - 메모리 관리 코드 drivers/ - 드라이버 ipc/ - IPC (Inter Process Communication) modules/ - 커널 모듈 fs/ - 파일시스템 kernel/ - 커널 코드 net/ - 네트워킹 코드 lib/ - 커널에서 사용하는 라이브러리 scripts/ - awk, tk와 같은 스크립트들(커널 configure 시에 사용) 구글링을 해보니 역시나 같은 생각을 한 사람이 있었다.</description>
    </item>
    
    <item>
      <title>비선점 스케쥴링(Nonpreemptive Scheduling)</title>
      <link>https://seokbeomKim.github.io/posts/nonpreemptive_scheduling/</link>
      <pubDate>Wed, 15 May 2019 18:44:06 +0900</pubDate>
      
      <guid>https://seokbeomKim.github.io/posts/nonpreemptive_scheduling/</guid>
      <description>비선점 스케쥴링(Non-preemptive Scheduling) 비선점 스케쥴링(Non-preemptive Scheduling)은 프로세스가 자원을 할당받았을 경우 자원을 스스로 반납할 때까지 계속 그 자원을 사용하도록 허용하는 정책이다. 적용할 때는 현재 프로세서를 사용하는 프로세스가 생성되거나 현재 프로세스 작업을 종료할 때 입출력하기 위해 스스로 프로세서를 반납할 때까지 우선 순위가 높은 프로세스의 비선점 정책을 적용하면 프로세스의 종료 시간을 비교적 정확하게 예측할 수 있다.
설명하기 전에 프로세스가 입출력 중심의 대화형 프로세스인지, 프로세서 실행 중심의 프로세스인지를 먼저 구분하는 것이 스케쥴링 정책을 적용하는 단계의 첫 번째이다.</description>
    </item>
    
  </channel>
</rss>
<!doctype html>
<html
  lang="en-us"
  dir="ltr"
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta name="language" content="en" />
<meta name="viewport" content="width=device-width" />
<title>
    Posts | 평범한 개발자
</title>
<meta property="og:url" content="http://localhost:1313/posts/">
  <meta property="og:site_name" content="평범한 개발자">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">


  <meta itemprop="name" content="Posts">
  <meta itemprop="datePublished" content="2024-09-09T22:39:58+09:00">
  <meta itemprop="dateModified" content="2024-09-09T22:39:58+09:00">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Posts">

<link rel="canonical" href="http://localhost:1313/posts/" /><link rel="alternate" type="application/rss&#43;xml" href="http://localhost:1313/posts/index.xml" /><link rel="alternate" type="application/json" href="http://localhost:1313/posts/index.json" />

    <link rel="stylesheet" href="/css/index.css" />


      <script src="/js/main.js" defer></script>
  
  



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "author": {
    "@type": "Person",
    "email": "sukbeom.kim@gmail.com",
    "name": "Sukbeom Kim",
    "url": "http://localhost:1313/about/"
  },
  "copyrightNotice": "Sukbeom Kim",
  "description": "",
  "headline": "Posts"
}
</script>


  </head>
  <body>
    <div class="container mx-auto flex max-w-prose flex-col space-y-10 p-4 md:p-6">
      <header class="flex flex-row items-center justify-between">
        <div>
  <a id="skip-nav" class="sr-only" href="#maincontent">Skip to main content</a>
  <a class="font-semibold" href="/">평범한 개발자</a>
</div>

  <nav>
    <ul class="flex flex-row items-center justify-end space-x-4">
    <li>
      <a aria-current="page" class="active" href="/posts/">Posts</a
      >
    </li>
    <li>
      <a href="/graph/">Graph</a
      >
    </li>
    <li>
      <a href="/about/">About</a
      >
    </li>
    </ul>
  </nav>


      </header>
      <main class="prose prose-slate relative md:prose-lg prose-h1:text-[2em]" id="maincontent">
        
  <h1 class="flex flex-row space-x-2 items-center">
    <span>Posts</span><a
        rel="alternate"
        type="application/rss+xml"
        href="/posts/index.xml"
        title="Subscribe to the Posts RSS feed"
        class="text-slate-300 hover:text-orange-600"
      >
        <svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  fill="none"
  stroke="currentColor"
  stroke-linecap="round"
  stroke-linejoin="round"
  stroke-width="2"
  class="lucide lucide-rss block"
>
  <path d="M4 11a9 9 0 0 1 9 9M4 4a16 16 0 0 1 16 16" />
  <circle cx="5" cy="19" r="1" />
</svg>

      </a>
  </h1>

  

  <div class="flex flex-col space-y-8">
    
    
      <section class="not-prose flex flex-col space-y-4">
        <h2 class="text-xl font-semibold opacity-60 text-right border-b">2019</h2>

        <div class="not-prose">
  <ol>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/locks-in-the-kernel-2/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >리눅스 커널 락 종류 (2/5)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-29T00:59:34&#43;09:00"
              >May 29, 2019</time
            >
          </header>

          <div class="text-sm">지난 번 포스팅에서는 리눅스 커널 락 중 하나인 스핀락(Spinlock)에 대해 기술하였다. 이번 포스팅에서는 뮤텍스(Mutex)에 대해서 기술하고자 한다. 많은 곳에서 뮤텍스는 세마포어의 카운트 값이 단순하게 1로 설정되었을 때를 말한다고 기술한다. 하지만 이것이 맞는 설명일까?
참고 자료에 따르면 뮤텍스는 공유 자원으로의 접근(Access)에 대한 상호 배제(Mutual Exclusion)을 위한 수단이 Mutex라고 정의하고 있다. 이에 반해 세마포어(Semaphore)는 시그널 매커니즘으로서 스레드(또는 프로세스) 간 동기화가 주 목적으로, wait 함수를 호출한 스레드만이 뮤텍스를 신호를 보낼 수 있다는 점이 기능적인 특징이다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/locks-in-the-kernel-1/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >리눅스 커널 락 종류 (1/5)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-28T17:45:51&#43;09:00"
              >May 28, 2019</time
            >
          </header>

          <div class="text-sm"><p>리눅스 커널에서 사용되는 락의 종류는 다양하다. 학부 시절, <em>&lsquo;뮤텍스는
세마 포어의 카운트가 1인 락&rsquo;이라는 말도 안되는 내용으로 학교
선배로부터 배웠던 것이 기억난다.</em> 락의 종류별로 쓰임새가 있고 장단점이
있는 것인데, 이 문서에는 커널에서 사용하는 락(lock)의 종류와 각각에
대한 사용 예를 기술하고자 한다.</p></div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/jiffies/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >지피(Jiffies)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-26T10:38:40&#43;09:00"
              >May 26, 2019</time
            >
          </header>

          <div class="text-sm">오랜만에 지피에 대한 포스팅을 다시 작성한다(대학생 때 커널 공부를 한 뒤로 이렇게 별도로 문서를 작성하는 것은 처음인 것 같다). 전역 변수인 jiffies에는 시스템 시작 이후 발생한 진동 횟수(tick)이 저장된다. 시스템 시작 시 커널은 이 값을 0으로 설정하고 타이머 인터럽트가 발생할 때마다 1씩 증가시킨다. 타이머 인터럽트는 초당 HZ회 발생하므로, 초당 지피 수는 HZ가 되며, 이에 따라 시스템 가동 시간은 jiffies / HZ(초)가 된다.
커널은 버그 식별을 위해 jiffies 변수의 오버플로우 현상이 자주 일어나기 위해 jiffies 변수를 0이 아닌 특별한 값으로 초기화하며 실제 jiffies값이 필요한 경우에는 이 차이(offset)값을 빼야 한다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/tasklet/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >태스크릿(Tasklet)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-25T17:32:26&#43;09:00"
              >May 25, 2019</time
            >
          </header>

          <div class="text-sm">커널 모듈 프로그래밍을 연습하던 도중, 태스크릿 예제를 접하게 되었다. 한참 전에 태스크릿이 어떤 것인지 이론으로 접하기는 했으나 직접 사용해본 적은 없었기 때문에 이 문서를 통해 정리하고자 한다.
간단히 말해 tasklet은 스택이나 자체 컨텍스트가 없는 스레드와 같은 것으로 설명하고 있다.
태스크릿(Tasklet)의 특성 태스크릿(tasklet)은 원자성을 가지고 있기 때문에 mutex, semaphore와 같은 동기화 수단을 사용하거나 sleep() 을 사용할 수 없다. 단, spinlock은 가능하다. ISR보다 유연한 컨텍스트(softer context)로 불린다. 때문에 태스크릿의 컨텍스트 도중 하드웨어 인터럽트가 발생하는 것을 허용한다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/build-kernel-and-busybox2/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >Linux 커널, Busybox 빌드 후 QEMU에서 실행하기(2/2)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-23T15:10:46&#43;09:00"
              >May 23, 2019</time
            >
          </header>

          <div class="text-sm">지난 번 포스팅에서는 단순하기 initramfs 램디스크를 만들어 busybox에 올리는 방법을 기술했었다. 그러면서 램디스크가 무엇인지 busybox는 무엇인지, 그리고 대략적인 빌드 디렉토리 구조를 파악할 수 있었던 기회였다.
두 번째 포스팅에서는 직접 busybox를 빌드하지 않고 crosstool-ng라는 크로스 컴파일러 생성 스크립트 도구와 buildroot라는 Makefile 패키지를 이용하여 램디스크를 만드는 방법에 대해 기술하겠다.
Crosstool-ng 이용하여 크로스 컴파일러 만들기 crosstool-ng는 미리 설정된 config를 이용해 손쉽게 크로스 컴파일러를 만들 수 있는 패키지이다. 이를 어떻게 이용하는지 자세히 설명하겠다.
먼저 crosstool-ng를 받는다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/build-kernel-and-busybox/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >Linux 커널, Busybox 빌드 후 QEMU에서 실행하기(1/2)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-22T19:35:04&#43;09:00"
              >May 22, 2019</time
            >
          </header>

          <div class="text-sm">취업은 언제하나&hellip; 커널 공부를 할 게 아니라 취업을 위한 알고리즘을 공부해야 하는데 커널 해킹을 위한 환경 구축만 하고 공부하자는 것이 꼬리에 꼬리를 물게 되었다. 커널 분석을 공부하고 궁금했던 사항들을 직접 확인해보기 위해 QEMU를 이용한 환경을 구축하기로 결정했다. 다행히도 나와 같은 생각을 한 사람이 있었고 매우 자세하게 설명을 해놓았기에 금방 해결할 수 있었다. 다만, 부팅 후 램디스크만을 이용하고 루트파티션은 마운트하지 않는다는 제한은 있다.
이 문서는 참고한 페이지를 토대로 필요한 정보들을 중간에 좀 더 추가한 형태로 정리하였다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/osi-7-layers/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >OSI 7-Layers</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-21T16:10:20&#43;09:00"
              >May 21, 2019</time
            >
          </header>

          <div class="text-sm">네트워크의 기본 개념인 OSI 7-Layers에 대해서 정리하고자 한다. 학부 시절 달달 외우기만 했던 까닭에 제대로 공부하지 못해 아쉬웠던 7계층 개념인데 외우기보다 이해하는 것이 훨씬 간단하므로, 필자의 경험을 이용해 (나중에 기억하기 쉽도록) 정리하고자 한다.
OSI 7계층에 대해 설명하기 위해 이 역시 방산업체에서의 경험을 이용하고자 한다. 아래는 OSI 7계층을 나타낸 그림이다. 이 때, 각 레이어들을 데이터들이 송수신될 때 전달되는 경로로 생각하며 그림을 이해해야 한다.
L1. 물리 계층, Physical Layer 물리 계층은 말 그대로 네트워크 장비들 간에 데이터를 송수신하기 위해 물리적으로 신호를 주고받는 계층이다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/tcp-and-udp/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >TCP와 UDP의 차이점</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-21T15:27:08&#43;09:00"
              >May 21, 2019</time
            >
          </header>

          <div class="text-sm">예전에 TCP, UDP에 대해서 정리해놓은 것들을 찾을 수 없어 블로그 페이지로 정리하고자 포스팅을 새로 만들었다. 앞으로 두고두고 찾아보게 될 페이지므로 향후 커널 소스 분석을 통해 TCP, UDP와 관련된 부분이 나올 경우 포스팅을 업데이트 할 예정이다.
방산 업체에서 무인 정찰기를 개발할 당시에도 중요 데이터는 모두 TCP를 이용해 송수신하고 영상과 같은 정보는 UDP를 이용해 전달받았다. 당시에 구현된 코드를 보면서 이전에 프로토콜 사용에 있어서 어디부터 어디까지를 UDP 혹은 TCP로 해야 하는가에 대해 논란이 있었을거라 예상했지만 코드를 변경할 수 없어 아쉬웠던 적이 있었다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/kernel-hacking-chapter-process/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >커널 해킹: 프로세스</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-16T18:59:15&#43;09:00"
              >May 16, 2019</time
            >
          </header>

          <div class="text-sm">앞으로 리눅스 커널 공부를 해가면서 포스팅으로 정리해둘 계획이다. 디바이스 드라이버 개발 이전에 리눅스라는 운영체제에 대해 개인적으로 정리해야할 필요성을 느꼈다. 그리고 최신 커널을 사용하기 보다 상대적으로 오래된 커널을 시작으로 공부하고자 한다. 기본 틀은 크게 변하지 않았을거라 생각하고 충분히 이해한 뒤에 최근 버전을 받아 개발 흐름을 이해하는 것이 옳은 방법이라 생각하였다.
이 문서에서는 리눅스/유닉스 운영체제의 기본 추상화 개념 중 하나인 프로세스에 대해 정리하고자 한다. 정리에 필요한 정보 수집을 위해서 Linux kernel development(3rd edition) 책과 LWN 등의 사이트들을 참고한다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/copy-on-write/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >Copy on Write (CoW or COW)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-16T18:24:16&#43;09:00"
              >May 16, 2019</time
            >
          </header>

          <div class="text-sm">Copy-on-write은 리눅스 커널의 fork() 함수에서 사용하는 기법이다.
전통적인 fork()는 부모 프로세스의 모든 자원을 복사해 자식 프로세스에게 넘겨준다. 하지만 이러한 방식은 공유가 가능한 많은 데이터를 복사하므로 단순하고 비효율적이다. 게다가 새로 만든 프로세스가 곧바로 다른 프로그램을 실행한다면 복사 작업이 모두 헛수고가 되고 만다.
이러한 문제를 해결하기 위해 리눅스에서는 Copy-on-write, COW 기법을 이용하는데 기록사항 발생 시에 복사하는 기능으로 즉각적인 데이터의 복사를 지연하거나 방지하는 기법이다. 때문에 fork()를 사용하게 되면 프로세스의 주소 공간을 모두 복사하는 대신, 부모와 자식 프로세스가 같은 공간을 공유하고 있다가 기록 사항이 발생했을 때 사본을 만든다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/kernel-module-and-drivers/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >커널 모듈과 드라이버의 차이</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-16T02:11:40&#43;09:00"
              >May 16, 2019</time
            >
          </header>

          <div class="text-sm">오랜만에 커널 공부를 다시 시작하면서 소스 트리를 다시 살펴보게 되었다. 분명히 예전에도 같은 질문을 가졌겠거니 생각하면서 트리를 보고 난 후의 첫 질문을 정리하고자 한다.
커널 디렉토리 구조는 대략 다음과 같이 구성되며, 그 중 drivers와 modules의 차이점이 이해하기가 어려웠다.
text text code snippet start
arch/ - 특정 아키텍처에 국한된 코드 include/ - 커널 빌드를 위해 포함하는 include 파일들 init/ - 커널 초기화 코드 mm/ - 메모리 관리 코드 drivers/ - 드라이버 ipc/ - IPC (Inter Process Communication) modules/ - 커널 모듈 fs/ - 파일시스템 kernel/ - 커널 코드 net/ - 네트워킹 코드 lib/ - 커널에서 사용하는 라이브러리 scripts/ - awk, tk와 같은 스크립트들(커널 configure 시에 사용) text code snippet end</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/nonpreemptive_scheduling/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >비선점 스케쥴링(Nonpreemptive Scheduling)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-15T18:44:06&#43;09:00"
              >May 15, 2019</time
            >
          </header>

          <div class="text-sm">비선점 스케쥴링(Non-preemptive Scheduling) 비선점 스케쥴링(Non-preemptive Scheduling)은 프로세스가 자원을 할당받았을 경우 자원을 스스로 반납할 때까지 계속 그 자원을 사용하도록 허용하는 정책이다. 적용할 때는 현재 프로세서를 사용하는 프로세스가 생성되거나 현재 프로세스 작업을 종료할 때 입출력하기 위해 스스로 프로세서를 반납할 때까지 우선 순위가 높은 프로세스의 비선점 정책을 적용하면 프로세스의 종료 시간을 비교적 정확하게 예측할 수 있다.
설명하기 전에 프로세스가 입출력 중심의 대화형 프로세스인지, 프로세서 실행 중심의 프로세스인지를 먼저 구분하는 것이 스케쥴링 정책을 적용하는 단계의 첫 번째이다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/deadlock/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >교착상태(Deadlock)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-15T17:40:14&#43;09:00"
              >May 15, 2019</time
            >
          </header>

          <div class="text-sm">교착 상태(Deadlock) 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 아무 것도 완료되지 않는 상태를 가리킨다. 이 문제를 해결하는 일반적인 방법은 아직 없는 상태다.
교착 상태는 하나의 사다리에 두 명이 사람이 매달려 있는 상황을 예상할 수 있다. 위쪽의 사람은 아래로 내려오려고 하고 아래에 있는 사람은 위로 올라가려고 한다면 서로 상대방이 사다리에서 비켜줄 때까지 계속 기다리고 있을 것이고 결과적으로 아무도 사다리에서 내려오거나 올라가지 못하듯이 교착 상태란 다중 프로그래밍 환경에서 흔히 발생할 수 있는 문제이다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/default-export-in-typescript/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >Named export와 Default export</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-07T16:30:51&#43;09:00"
              >May 7, 2019</time
            >
          </header>

          <div class="text-sm">개요 모듈 프로그래밍 기반인 자바스크립트는 모듈 방식은 처음 접했을 때 이해가 되지 않았다. 특히 default export와 named export 라는 export 방식과 자바스크립트 버전에 따른 문법 호환 때문에 모듈 export와 import, require를 사용하는 코드를 이해하기 힘들었다.
이 문서에서는 타입스크립트를 이용하여 default, named export 각각을 구현한 뒤 import, require 키워드 각각을 이용하였을 때 레퍼런스 변수가 어떤 값을 가지고 있는지 확인한다.
직접 확인해보자 첫 번째 테스트 먼저 export할 테스트 클래스를 간단하게 구현한다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/tensorflow-scikit-learn/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >텐서플로우(Tensorflow)와 사이킷런(Scikit-learn)의 차이</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-06T17:05:11&#43;09:00"
              >May 6, 2019</time
            >
          </header>

          <div class="text-sm">책장 속에서 잊혀져 갔던 머신러닝 책을 꺼내 읽기 시작했다. 책을 받았을 당시에는 회사 출장으로 읽을 시간이 없었는데 이제서야 몇 개월이 지나서야 마음이 안정되어 이 책을 꺼내보게 되었다.
각설하고, 책의 모든 내용이 사이킷런(Scikit-learn)을 이용하는데 문득 텐서플로우(Tensorflow)와의 차이점이 무엇인지 궁금해졌다. 통상적으로 머신러닝이라 하면 텐서플로우를 많이 쓰는데, 굳이 사이킷런을 사용하는 이유가 있을까 궁금해졌다.
왜 라이브러리가 아닌 프레임워크라 부르는지 모르겠지만, 이들은 분류, 회귀, 클러스터링, 비정상행위 탐지, 데이터 준비를 위한 다양한 학습 방법을 다루며 인공 신경망 메서드를 포함할 수도, 포함하지 않을 수도 있다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/unsupervised-supervised-learning/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >비지도 학습 알고리즘과 지도 학습</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-06T15:31:38&#43;09:00"
              >May 6, 2019</time
            >
          </header>

          <div class="text-sm">개요 프로젝트 진행을 위해 필요한 머신러닝을 배우기 위해 책을 펼쳤다. 제일 먼저 나오는 개념이 지도 학습(Supervised Learning)과 비지도(Unsupervised Learning)이었는데 어디에도 학습이 정확이 무엇인지에 대한 내용이 없었다.
학습이란 무엇인가? 질문에 대한 답은 쉽게 찾을 수 있었다.(해당 링크)
text text code snippet start
A model with a set of parameters transforms the input into an output, this generates a signal from which the model updates the parameters to produce a new output.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/java-inner-class/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >자바의 중첩 클래스(Nested Class)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-03T20:38:14&#43;09:00"
              >May 3, 2019</time
            >
          </header>

          <div class="text-sm">개요 중첩 클래스(Nested Class)에 대해서 여러 사이트에서 설명해놓은 것이 있지만 잘못 설명되어 있는 부분도 있었다. &lsquo;Nested Class는 Inner Class와 같다.&rsquo; 라는 식으로 기술해놓은 페이지가 많아 이번 기회에 확실하게 정리해놓고자 한다.
중첩 클래스(Nested Class)는 내부 클래스(Inner Class)와 같은 개념이 아니라 포함 관계이다. 중첩 클래스는 static 사용 여부에 따라, 정적 중첩 클래스(Static nested class)와 비정적 중첩 클래스(Non-static nested class)로 구분하며, 통상적으로 각각을 정적 중첩 클래스(Static Nested Class), 내부 클래스(Inner Class)라고 한다. 중첩 클래스와 내부 클래스를 같은 개념으로 혼용하는 용례가 많다는데 static 여부에 따라 구분되어 서로 다르다는 것을 반드시 알고 있자.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/servlet-container/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >서블릿 컨테이너와 서버와의 관계</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-03T17:50:32&#43;09:00"
              >May 3, 2019</time
            >
          </header>

          <div class="text-sm">개요 아파치 서버에 톰캣(tomcat)을 이용하여 젠킨스와 같은 애플리케이션을 올려본 적은 있어도 직접 서블릿 컨테이너에서 사용할 수 있는 애플리케이션은 개발해 본 적이 없다. 때문에 서블릿이라는 용어 자체가 생소하고 웹 서버에서 이를 어떻게 관리하는지에 대해 궁금한 점을 중점으로 정리하고자 한다.
정리하고자 하는 질문은 아래와 같다.
Apache나 Nginx에서 서블릿 컨테이너로 어떤 방식을 통해서 클라이언트 요청을 넘겨주는가? 서블릿 컨테이너가 만들어진 이유는 무엇인가? 애플리케이션의 서블릿은 서블릿 컨테이너가 가지고 있는 라이프사이클 중 언제 추가되는가? 애플리케이션이 가지는 서블릿은 서블릿 컨테이너에 어떤 형태로 추가되는가?</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/partition-and-sharding/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >파티셔닝(Partitioning)과 샤딩(Sharding)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-01T20:29:02&#43;09:00"
              >May 1, 2019</time
            >
          </header>

          <div class="text-sm">개요 데이터베이스에 관련된 문서를 보다보니 Partition, Sharding이라는 용어들이 등장하기 시작하기 시작했다. 이러한 것들은 말 그 대로 데이터베이스를 여러 개로 나누어 분산시키기 위한 기술 용어들인데 모두 서비스 크기 증가에 따른 DB 크기 증가, 성능 이슈에 따른 것이다. 일명 VLDB(Very Large DBMS)라 불리는, DBMS 하나로 전체 데이터베이스를 다룰 수 없는 데이터베이스가 자연스럽게 등장하였고 DBMS 한 개가 여러 개의 테이블을 관리하면서 성능 이슈도 생기게 되었는데 이를 해결하기 위한 것이 바로 파티셔닝(partitioning) 과 샤딩(Sharding)이다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/rest-api-model/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >RESTful 성숙도 모델, Richardson Maturity Model(RMM)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2019-05-01T18:38:22&#43;09:00"
              >May 1, 2019</time
            >
          </header>

          <div class="text-sm">개요 이 문서는 진행하는 프로젝트에서 백엔드 서버에서 제공할 REST API를 어떻게 설계해야 하는가에 대해 공부하던 중 인터넷에서 찾은 문서를 정리한 것이다. 이 문서에서는 REST 소개부터 API 설계 방법, 그리고 설계한 API가 &lsquo;RESTful&rsquo; 이라는 형용사를 붙일 수 있는지 판단할 수 있는 &lsquo;Richardson Maturity Model&rsquo;이라는 성숙도 모델을 기술한다.
REST 소개 이 절은 Microsoft의 REST 소개를 발췌하여 정리한 것이다.
REST는 하이퍼미디어 기반 분산 시스템을 구축하기 위한 아키텍처 스타일로서 프로토콜과는 관련이 없는 용어이다. (일각에서 REST와 SOAP를 비교하는 글들이 많아 언급하였다.</div>
        </article>
      </li>
  </ol>
</div>

      </section>
      
  <ul class="pagination">
    
      
        <li class="page-item">
          <a href="/posts/" aria-label="First" class="page-link" role="button"
            ><span aria-hidden="true">&laquo</span></a
          >
        </li>
      <li class="page-item">
        <a href="/posts/page/4/" aria-label="Previous" class="page-link" role="button"
          ><span aria-hidden="true">&#8249;</span></a
        >
      </li>
        <li class="page-item">
          <a
            href="/posts/page/2/"
            aria-label="Page 2"
            class="page-link"
            role="button"
            >2</a
          >
        </li>
        <li class="page-item">
          <a
            href="/posts/page/3/"
            aria-label="Page 3"
            class="page-link"
            role="button"
            >3</a
          >
        </li>
        <li class="page-item">
          <a
            href="/posts/page/4/"
            aria-label="Page 4"
            class="page-link"
            role="button"
            >4</a
          >
        </li>
        <li class="page-item active">
          <a
            aria-current="page"
            aria-label="Page 5"
            class="page-link"
            role="button"
            >5</a
          >
        </li>
        <li class="page-item">
          <a
            href="/posts/page/6/"
            aria-label="Page 6"
            class="page-link"
            role="button"
            >6</a
          >
        </li>
      <li class="page-item">
        <a href="/posts/page/6/" aria-label="Next" class="page-link" role="button"
          ><span aria-hidden="true">&#8250;</span></a
        >
      </li>
        <li class="page-item">
          <a href="/posts/page/6/" aria-label="Last" class="page-link" role="button"
            ><span aria-hidden="true">&raquo;</span></a
          >
        </li>
  </ul>
  </section>
  </div>

      </main>
      <footer class="mt-20 border-t border-neutral-100 pt-2 text-xs">
        <section class="items-top flex flex-row justify-between opacity-70">
  <div class="flex flex-col space-y-2">
      <p>Copyright &copy; 2024, Sukbeom Kim.</p>

  </div>
    <div>
      <a
        href="https://github.com/michenriksen/hugo-theme-til"
        title="Today I Learned &#8212; A Hugo theme by Michael Henriksen"
        data-theme-version="0.6.0"
        >theme: til</a
      >
    </div>
</section>

      </footer>
    </div>
    
  </body>
</html>

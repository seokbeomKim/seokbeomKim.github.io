<!doctype html>
<html
  lang="en-us"
  dir="ltr"
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
<meta name="language" content="en" />
<meta name="viewport" content="width=device-width" />
<title>
    Posts | 평범한 개발자
</title>
<meta property="og:url" content="http://localhost:1313/posts/">
  <meta property="og:site_name" content="평범한 개발자">
  <meta property="og:title" content="Posts">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">


  <meta itemprop="name" content="Posts">
  <meta itemprop="datePublished" content="2024-09-09T22:39:58+09:00">
  <meta itemprop="dateModified" content="2024-09-09T22:39:58+09:00">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Posts">

<link rel="canonical" href="http://localhost:1313/posts/" /><link rel="alternate" type="application/rss&#43;xml" href="http://localhost:1313/posts/index.xml" /><link rel="alternate" type="application/json" href="http://localhost:1313/posts/index.json" />

    <link rel="stylesheet" href="/css/index.css" />


      <script src="/js/main.js" defer></script>
  
  



<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "author": {
    "@type": "Person",
    "email": "sukbeom.kim@gmail.com",
    "name": "Sukbeom Kim",
    "url": "http://localhost:1313/about/"
  },
  "copyrightNotice": "Sukbeom Kim",
  "description": "",
  "headline": "Posts"
}
</script>


  </head>
  <body>
    <div class="container mx-auto flex max-w-prose flex-col space-y-10 p-4 md:p-6">
      <header class="flex flex-row items-center justify-between">
        <div>
  <a id="skip-nav" class="sr-only" href="#maincontent">Skip to main content</a>
  <a class="font-semibold" href="/">평범한 개발자</a>
</div>

  <nav>
    <ul class="flex flex-row items-center justify-end space-x-4">
    <li>
      <a aria-current="page" class="active" href="/posts/">Posts</a
      >
    </li>
    <li>
      <a href="/graph/">Graph</a
      >
    </li>
    <li>
      <a href="/about/">About</a
      >
    </li>
    </ul>
  </nav>


      </header>
      <main class="prose prose-slate relative md:prose-lg prose-h1:text-[2em]" id="maincontent">
        
  <h1 class="flex flex-row space-x-2 items-center">
    <span>Posts</span><a
        rel="alternate"
        type="application/rss+xml"
        href="/posts/index.xml"
        title="Subscribe to the Posts RSS feed"
        class="text-slate-300 hover:text-orange-600"
      >
        <svg
  xmlns="http://www.w3.org/2000/svg"
  width="24"
  height="24"
  fill="none"
  stroke="currentColor"
  stroke-linecap="round"
  stroke-linejoin="round"
  stroke-width="2"
  class="lucide lucide-rss block"
>
  <path d="M4 11a9 9 0 0 1 9 9M4 4a16 16 0 0 1 16 16" />
  <circle cx="5" cy="19" r="1" />
</svg>

      </a>
  </h1>

  

  <div class="flex flex-col space-y-8">
    
    
      <section class="not-prose flex flex-col space-y-4">
        <h2 class="text-xl font-semibold opacity-60 text-right border-b">2020</h2>

        <div class="not-prose">
  <ol>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/type-check-in-c/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >C언어에서의 type-check</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-04-10T00:13:53&#43;09:00"
              >April 10, 2020</time
            >
          </header>

          <div class="text-sm">개요 리눅스 커널을 살펴보다 보면 독특한 형태의 매크로 또는 타입 정의를 통해 타입 체크를 하는 것을 알 수 있다. 이 페이지에서는 앞으로 커널 분석 중에 자주 보게될 타입 체크에 대해 정리하고 내용이 추가될 때마다 페이지를 업데이트 하도록 한다.
페이지 테이블에서의 타입 체크 ARM64 커널 소스에 있는 MMU 코드를 살펴보니 아래와 같이 특이하게 작성되어 있는 부분을 찾을 수 있었다.
c&#43;&#43; c&#43;&#43; code snippet start
typedef u64 pteval_t; typedef u64 pmdval_t; typedef u64 pudval_t; typedef u64 pgdval_t; .</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/dmips/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >DMIPS (Dhrystone Million Instructions Per Second)</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-04-03T01:41:29&#43;09:00"
              >April 3, 2020</time
            >
          </header>

          <div class="text-sm">개요 프로세서의 성능을 나타내는 지표로서 DMIPS라는 것을 사용하게 되었다. 벤치마크로 MIPS만 알고 있었는데 실제로 업무에서 사용했던 것은 DMIPS라는 것이어서 이번에 확실하게 정리하고 가고자 한다.
DMIPS는 드라이스톤(Dhrystone) 벤치마크 테스트의 결과를 정수화해서 이를 하중한 값으로 비교하는 방법으로 프로세서 성능 비교에 이용하는 지표이다. 예를 들어, ARM 32bit Cortex-M3 CPU - 72 MHz maximum frequency 모델의 경우 1.25 DMIS/MHz 인데 여기에 CPU 사용량을 이용하면 해당 프로세서가 가지는 Full DMIPS (72MHz 일 때의 DMIPS) 대비 측정하고자 하는 프로세스에 대한 DMIPS 지표를 얻을 수 있다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/futex/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >Futex</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-04-02T01:45:50&#43;09:00"
              >April 2, 2020</time
            >
          </header>

          <div class="text-sm">Futex (Fast Userspace Mutexes) futex는 전통적인 UNIX 커널에서 사용되고 있는 sleep/wakup과 매우 비슷한 동기 기구를 userland에 대해 제공한다. 주로 NPTL(Native POSIX Thread Library) 등의 라이브러리의 구현에 사용되기 때문에 애플리케이션으로부터 직접 이용하는 경우는 별로 없다고 생각되지만 POSIX Thread는 Java 스레드의 구현 등에도 이용되고 있어 동기 처리를 많이 이용하는 애플리케이션에는 이익이 있을 것이다. futex 시스템 콜의 주된 기능은 FUTEX_WAIT와 FUTEX_WAKE이다.
pthread_mutex_lock 아토믹 명령을 사용하여 lock을 시도 1에서 lock이 성공되면 종료 FUTEX_WAIT를 사용하여 pthread_mutex_t의 주소 상에서 슬립한다 시동 후, 1로 돌아간다 pthread_mutex_unlock 아토믹 명령을 사용해 unlock 처리를 실시 1의 결과, 슬립하고 있는 스레드가 있다면 FUTEX_WAKE를 사용하여 wakeup한다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/do-while/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >Do While</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-04-01T23:55:32&#43;09:00"
              >April 1, 2020</time
            >
          </header>

          <div class="text-sm">개요 커널 매크로에 do { .. } while(0) 구문을 사용하는 것을 보게 되었다. 사내 코드에서도 이러한 구문들이 많이 보였는데 처음에는 의미없이 이상하게 짜여진 코드라고 생각했다. 그런데 그런 구문에도 의미가 있었다. https://kernelnewbies.org/FAQ/DoWhile0 링크를 보면 이러한 구문을 만든 이유가 기술되어 있다. 이러한 구문에 대한 이유는 아래와 같다.
빈 구문(empty statement)는 컴파일러가 경고를 낸다. 지역 변수를 선언할 수 있는 구역을 만들어준다. 조건문을 포함한 코드에서 복잡한 형태의 매크로를 사용할 수 있도록 해준다. 조건문을 포함한 코드에서의 매크로 사용 c&#43;&#43; c&#43;&#43; code snippet start</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/bsd_queue/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >BSD 버전 Linked List</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-04-01T00:26:52&#43;09:00"
              >April 1, 2020</time
            >
          </header>

          <div class="text-sm">개요 사내에서 소스 파일에 대한 라이센스를 정리하기 시작하면서 기존 애플리케이션에서 리눅스의 pipe 를 이용하여 구현된 메세지 큐를 연결 리스트로 재작성하는 작업을 맡게 되었다. 처음에는 리눅스의 커널에서 제공하는 list.h 를 사용하지 못해서 연결 리스트를 학부시절에 사용하던 방식으로 직접 구현하고자 하였다. 하지만 조금 더 찾아보니 BSD 버전의 연결 리스트가 &lt;sys/queue.h&gt; 의 형태로 존재하고 있었고 현재 FreeBSD에 포함되어 있는 queue.h 와는 다르지만 오래 전 공유하던 레거시 코드로서 여전히 리눅스 커널 내에 BSD 커널 라이브러리를 간직하고 있었다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/c-arraysize-macro/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >C ARRAY_SIZE 매크로와 포인터 기초</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-03-28T00:54:01&#43;09:00"
              >March 28, 2020</time
            >
          </header>

          <div class="text-sm">개요 칩 검증 코드를 수정하기 위해 간단한 루틴을 작성하고 있던 도중 커널에서 제공하는 ARRAY_SIZE 매크로가 의도한대로 동작하지 않아 살펴보기 시작했다. 그러던 도중 https://kldp.org/node/34268과 같은 원인이라는 것을 알게되고 C 기초를 또 다시 한번 공부하게 되었다.
커널에서 사용하는 ARRAY_SIZE는 아래와 같이 구현되어 있다.
c&#43;&#43; c&#43;&#43; code snippet start
#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0])) // examples for (idx = 0; idx &lt; ARRAY_SIZE(pArr); idx++) { // do something }) c&#43;&#43; code snippet end
본래 의도한대로라면, 배열의 크기만큼 for 구문을 반복해서 수행해야 하지만, pArr 자체가 함수의 인자로써 전달된 것이라면 얘기가 달라진다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/goto-statement/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >goto statement</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-03-25T00:47:49&#43;09:00"
              >March 25, 2020</time
            >
          </header>

          <div class="text-sm">개요 학부 시절 c언어를 배울 때 &lsquo;goto&rsquo; 문을 사용하는 것을 터부시할 정도로 절대 사용하면 안되는 문법으로 배웠다. 그 이유는 자세하게 알려주지 않았지만 되도록이면 goto 를 사용하지 않고 분기나 객체를 이용하도록 코딩을 했었고 저학년에서 고학년으로 올라갈수록 c언어 대신 자바나 c++, c# 등을 배우면서 goto는 머릿속에서 잊혀져갔다.
입사하고 나서 드라이버 코드를 보니 간간히 goto 문이 사용된 것들을 보고 이것이 과연 리팩토링을 해야하는 대상인가에 대해 잠시 생각해보았다. 만약 아래와 같이 코드가 진행될 경우, 반드시 나머지 코드를 분기문으로 처리해야할 필요가 있을까?</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/android-partitions/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >안드로이드 파티션</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-03-12T00:26:40&#43;09:00"
              >March 12, 2020</time
            >
          </header>

          <div class="text-sm">개요 안드로이드 기본 내용이지만 파티션을 착각한 탓에 수정 사항을 반영하지 못해 시간을 날리고 말았다. 커널의 수정사항이라 부트 이미지만 적용하면 변경 사항이 적용될 거라 생각했지만 커널 모듈로 빌드되는 경우 vendor 이미지로 별도로 관리될 수도 있기 때문에 해당 이미지도 함께 추가해서 해당 파티션도 업데이트 해줘야 한다.
안드로이드 파티션 안드로이드 레퍼런스 문서에 따르면 boot, system, vendor, radio를 다음과 같이 설명하고 있다.
boot: boot 파티션에는 mkbootimg를 통해 결합된 커널 이미지와 RAM 디스크가 포함된다. 새 boot 파티션을 플래시하지 않고 직접 커널을 플래시 하기 위해 가상 파티션을 사용할 수 있다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/poll-and-poll_wait/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >poll() 그리고 poll_wait()</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-03-10T23:52:01&#43;09:00"
              >March 10, 2020</time
            >
          </header>

          <div class="text-sm">개요 업무 중에 카메라 드라이버에 관련된 이슈를 보다가 poll()과 poll_wait()이 지속적으로 사용되는 것을 볼 수 있었다. 이슈에 관련된 커널이 다소 오래되었기에 살펴보아야 하는 드라이버 코드도 레거시에 가까웠지만 poll을 이용하여 디바이스 드라이버의 인터럽트를 처리하는 것으로 확인하여 관련 내용을 정리하고자 한다.
리눅스 커널에서 제공하는 poll 함수에 대해서 원문으로 작성된 여러 출처들이 있었지만 아무래도 처음부터 원문을 읽고 이해하기에는 다소 어려움이 있었다. falinux에 작성된 문서를 기반으로 아래와 같이 개념적인 내용만 재정리하는 방식으로 포스팅을 작성하려 한다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/micom-vs-mpu/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >MICOM과 MPU</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-03-08T23:30:44&#43;09:00"
              >March 8, 2020</time
            >
          </header>

          <div class="text-sm">개요 카메라 관련 업무로 ARM Cortex A7 Single 모델을 주로 사용하지만 A53, MICOM 과의 인터럽트 충돌 문제가 일어날 때가 있다. UART 부트 및 LVDS 채널 변경, 더 나아가 카메라 센서의 초기화까지 마이컴에서 담당하게 되는 시나리오가 있어 마이컴이 정확히 어떤 것인지 한번은 짚고 넘어가야 했다.
마침 한 블로그에 마이컴에 대해 간략하게 정리가 되어 있고 연관된 토픽 별로 정리해놓은 페이지가 있어 필요한 부분만 간추려 본 페이지로 정리하기로 한다.
본문 출처 내용 그대로 uC는 MicroController, uP는 MicroProcessor, &ldquo;Adv&quot;는 Advanced Topic의 줄임말로서 사용한다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/ioctl-and-interrupt/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >IOCTL과 인터럽트</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-03-03T00:00:10&#43;09:00"
              >March 3, 2020</time
            >
          </header>

          <div class="text-sm">개요 디바이스 드라이버와 인터럽트 핸들러 간의 동기화 때문에 머리가 아팠다. 현재도 해결하지 못하고 있는 이슈가 있어 계속해서 찾아보고 있는 와중에 StackOverflow에서 재미있는 질문을 찾았다.
[[https://stackoverflow.com/questions/60088342/does-context-switching-occurs-when-ioctl-is-issued-from-user-space-while-kernel]] 문제 자체는 커널 모듈 안에 있는 critical section에서 스핀락을 사용하지 않을 때 irq나 softirq를 비활성화하지 않고도 데드락에 빠지지 않고 정상적으로 동작이 가능한가에 대한 질문이다. 질문에 대한 답변부터 살펴보면,
IRQ/SoftIRQ는 시스템 콜과 아무런 영향이 없다. 단지 인터럽트 컨텍스트 안에서 사용되는 데이터 구조들을 보호하기 위해 IRQ와 softIRQ를 비활성화하는 것 뿐이다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/static-ipaddr-for-hyper-v/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >Hyper-V 가상 환경에서 고정 아이피 주소 사용하기</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-03-01T17:12:34&#43;09:00"
              >March 1, 2020</time
            >
          </header>

          <div class="text-sm">개요 윈도우즈에서 리눅스 환경을 이용하기 위해서는 docker 컨테이너를 이용하거나 hyper-v, vmware, virtualbox 등과 같은 가상머신을 이용해야 한다. 이번에는 hyper-v를 이용해 리눅스 환경을 구축하고 SSH를 통해 접속하여 필요한 작업을 하려 했는데 문제는 IP가 계속해서 동적으로 바뀌는 것이었다. 이를 해결하기 위해 네트워크 구성 방법과 간단한 가이드를 작성하고자 한다. 향후 Hyper-V 를 사용하면서 요구되는 시나리오가 추가되면 본 포스팅 문서를 수정하여 정리하도록 한다.
가상머신 클라이언트에 static ip 할당하기 가상머신에 고정 아이피를 할당하기 위해서는 가상 스위치 장치를 이용해야 한다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/buffering-in-linux/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >리눅스에서의 버퍼링 방식</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-02-29T23:34:30&#43;09:00"
              >February 29, 2020</time
            >
          </header>

          <div class="text-sm">리눅스에서의 버퍼링 정책 리눅스에서는 파일 입출력을 할 때 물리적인 파일에 조회 및 기록의 횟수를 최소화하여 성능을 높이기 위해 버퍼링 정책을 사용하고 있다.
만약 write 호출로 데이터를 쓰기 명령을 전달하면 해당 파일 작업을 위한 버퍼에 기록을 해 두었다가 정책에 따라 특정 시점에 물리적인 파일에 기록을 수행한다. 리눅스에서 제공하는 버퍼링 정책에는 버퍼가 꽉 차면 물리적인 파일에 기록하는 Full Buffering과 꽉 차거나 개행문자가 오면 처리하는 Line Buffering, 버퍼를 사용하는 않는 Null Buffering 정책을 제공하고 있다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/ioctl_cmd_macro/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >ioctl()에 전달되는 cmd 관련 매크로 함수</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-02-27T00:23:10&#43;09:00"
              >February 27, 2020</time
            >
          </header>

          <div class="text-sm">드라이버 코드 내에서 ioctl commands 를 정의하기 위해 단순 integer를 사용하는 게 아니라 매크로를 통해 생성을 하고 있었다. 이에 관련 내용을 포스팅과 함께 정리하고자 한다.
저수준 파일 입출력 함수인 ioctl()을 디바이스 파일에 적용시키면 디바이스 파일에 연결된 디바이스 드라이버의 file_operation 구조체의 ioctl 필드에 선언된 함수가 호출된다. ioctl 함수는 디바이스마다 고유하게 선언하여 사용하는데, 일반적으로 하드에워의 제어나 상태를 얻기 위해 사용한다.
cmd 구성 디바이스 드라이버의 ioctl() 함수에 전달되는 매개변수 cmd는 응용 프로그램이 디바이스 드라이버에게 요구한 처리를 구별하기 위한 구별값이다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/switch-statement/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >switch 구문과 if-else 구문</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-02-26T23:56:18&#43;09:00"
              >February 26, 2020</time
            >
          </header>

          <div class="text-sm">개요 실행 시간 단축을 위해 어떤 방법이 가능할지 고민하던 중 아래와 같은 case 구문을 보았다.
c&#43;&#43; c&#43;&#43; code snippet start
int switch_example(unsigned int flag) { switch (flag) { case FLAG_A: // do A break; case FLAG_B: // do B break; case blabla: // blabla... break; default: printk(KERN_ERR &#34;ERROR!\n&#34;); } return 0; } c&#43;&#43; code snippet end
함수 포인터 배열 사용하기 if-else 를 사용하지 않고 굳이 switch 문을 사용하는 이유가 있을까?</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/idmap/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >Identity Mapping</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-02-24T23:01:54&#43;09:00"
              >February 24, 2020</time
            >
          </header>

          <div class="text-sm">ARM64 페이징을 공부하다보니 idmap (Identity Mapping)이라는 용어가 등장했다. 페이지 테이블이 완전하게 준비가 되지 않았을 때 임시로 사용하는 매핑 방법 중의 하나인데 오늘을 여기에 대해서 정리하고자 한다.
idmap이 무엇이고 왜 필요한가? idmap 을 사용하는 코드는 어떤 것이 있는가? ARM 리눅스 커널에서는 어떻게 활용하고 있는가? idmap (Identity Mapping) 가상주소와 물리주소가 매핑되는 방식 중의 한 가지다. 리눅스 커널에서 사용하는 주소 매핑 방식을 아래와 같이 3가지로 구분할 수 있다.
linear 영역 가상주소 + offset = 물리주소 와 같이 주소 변환이 가능한 방식이다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/linux-on-macbook/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >맥북에 리눅스 설치, 그리고 hyper-v</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-02-22T18:41:53&#43;09:00"
              >February 22, 2020</time
            >
          </header>

          <div class="text-sm">개요 맥을 사용하다보니 점점 운영체제가 갖는 한계가 느껴졌다. 지난 1년 반 동안 사용하면서 느꼈던 점은 윈도우즈와 리눅스의 장점만을 취한 운영체제였지만 동시에 맥 만의 단점을 갖고 있었고 생각보다 매우 영향이 컸다.
PIM은 기본이고 상위 레벨 프로그래밍을 위해서, 맥 만큼 좋은 운영체제는 없을 것이다. BSD 기반으로 만들어져 완벽하지는 않지만 포팅을 하면 어느정도 리눅스에 가까울 정도로 네이티브 환경에서 실행 가능하고 다양한 분야에서 강력한 유료 애플리케이션이 지원되기 때문에 만족스럽게 사용할 수 있다.
하지만 맥은 WSL을 도입하면서 윈도우즈가 갖게된 리눅스 플랫폼(?</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/warn_on-and-bug_on/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >WARN_ON, BUG_ON 매크로</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-02-21T00:12:34&#43;09:00"
              >February 21, 2020</time
            >
          </header>

          <div class="text-sm">개요 업무 중에 예전 SDK에서 커널 패닉이 일어나는 것을 보고 관련 코드를 살펴보니, BUG_ON 매크로 사용에 의한 것으로 파악했다. 커널 패닉을 일으킬 정도로 크리티컬은 아니었기에 해당 매크로를 WARN_ON으로 변경하였다. 변경 이후에 커널 패닉은 일어나지 않았지만 커널 메시지로 보여주는 내용이 조금 달랐다.
이 글에서는 BUG_ON, WARN_ON 등 커널에서 제공하는 assertion에 해당하는 매크로가 어떤 것들이 있는지 살펴보고 어떤 경우에 사용해야 하는지에 대해 간략히 정리하고자 한다. 이 외에 커널에서는 dump_stack(), save_stack_trace(), dump_trace(), backtrace() 등의 콜 스택 출력 방법을 제공한다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/likely-and-unlikely/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >Likely and Unlikely</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-02-13T23:27:51&#43;09:00"
              >February 13, 2020</time
            >
          </header>

          <div class="text-sm">개요 예전에 관리하던 블로그에서 커널에서 사용하는 likely와 unlikely 에 대해서 정리한 포스팅이 있었다. 하지만 시간이 지나 커널 분석 책을 다시 보며 likely, unlikely를 보니 다시 헷갈리기 시작했다.
회사 업무에서 실행 시간을 줄이는 데에 중요도를 두고 있지만 그 방법에 대해서는 아직 다루지 못하고 있다. 솔루션이 안정화되고 전체적인 업무 내용이 파악되면 본 내용을 정리하면서 실행 시간을 감소할 방법으로 prediction을 이용하는 것을 건의해보고 진행해볼 수 있을 것 같다.
likely(), unlikely() 함수의 이름 그대로, 자주 일어날 듯하거나 자주 일어나지 않을 듯한 것을 위한 매크로이다.</div>
        </article>
      </li>
      <li class="mb-6">
        <article class="flex flex-col space-y-1">
          <header>
            <h3 class="text-lg font-semibold leading-none">
              <a
                href="/posts/typedef-is-evil/"
                class="underline decoration-slate-300 decoration-2 underline-offset-4 hover:decoration-inherit"
                >typedef is evil</a
              >
            </h3><time class="text-sm italic leading-5 opacity-80" datetime="2020-02-13T01:12:37&#43;09:00"
              >February 13, 2020</time
            >
          </header>

          <div class="text-sm">커널 쪽의 코드를 보다가 문득 커널 코드에 적용하는 코딩 규칙에 대해서 궁금해졌다. 관련 내용으로 검색하다보니 재미있는 포스팅 하나를 발견했다. typedef is evil 이라는 제목의 포스팅이었다. 이 포스팅에서는 아래와 같이 사용하는 것을 비판하고 있다. 2000년도 초반에 작성된 것이니, 벌써 20년 가까이 되었는데도 불구하고 여전히 코드에 남아있다는 점이 아이러니하다.
c&#43;&#43; c&#43;&#43; code snippet start
typedef struct foo { int bar; int baz; } foot_t, *pfoo_t; c&#43;&#43; code snippet end
위와 같이 구조체에 대한 포인터를 정의할 때 typedef을 이용하지 말 것을 당부한다.</div>
        </article>
      </li>
  </ol>
</div>

      </section>
      
  <ul class="pagination">
    
      
        <li class="page-item">
          <a href="/posts/" aria-label="First" class="page-link" role="button"
            ><span aria-hidden="true">&laquo</span></a
          >
        </li>
      <li class="page-item">
        <a href="/posts/page/2/" aria-label="Previous" class="page-link" role="button"
          ><span aria-hidden="true">&#8249;</span></a
        >
      </li>
        <li class="page-item">
          <a
            href="/posts/"
            aria-label="Page 1"
            class="page-link"
            role="button"
            >1</a
          >
        </li>
        <li class="page-item">
          <a
            href="/posts/page/2/"
            aria-label="Page 2"
            class="page-link"
            role="button"
            >2</a
          >
        </li>
        <li class="page-item active">
          <a
            aria-current="page"
            aria-label="Page 3"
            class="page-link"
            role="button"
            >3</a
          >
        </li>
        <li class="page-item">
          <a
            href="/posts/page/4/"
            aria-label="Page 4"
            class="page-link"
            role="button"
            >4</a
          >
        </li>
        <li class="page-item">
          <a
            href="/posts/page/5/"
            aria-label="Page 5"
            class="page-link"
            role="button"
            >5</a
          >
        </li>
      <li class="page-item">
        <a href="/posts/page/4/" aria-label="Next" class="page-link" role="button"
          ><span aria-hidden="true">&#8250;</span></a
        >
      </li>
        <li class="page-item">
          <a href="/posts/page/6/" aria-label="Last" class="page-link" role="button"
            ><span aria-hidden="true">&raquo;</span></a
          >
        </li>
  </ul>
  </section>
  </div>

      </main>
      <footer class="mt-20 border-t border-neutral-100 pt-2 text-xs">
        <section class="items-top flex flex-row justify-between opacity-70">
  <div class="flex flex-col space-y-2">
      <p>Copyright &copy; 2024, Sukbeom Kim.</p>

  </div>
    <div>
      <a
        href="https://github.com/michenriksen/hugo-theme-til"
        title="Today I Learned &#8212; A Hugo theme by Michael Henriksen"
        data-theme-version="0.6.0"
        >theme: til</a
      >
    </div>
</section>

      </footer>
    </div>
    
  </body>
</html>

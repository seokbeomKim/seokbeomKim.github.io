<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>안드로이드의 uevent, ueventd | Sukbeom Kim</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="개요 🔗디바이스 트리와 카메라 포팅에 관련된 디바이스 드라이버 코드를 적절하게 수정한 뒤에도 계속해서 디바이스가 정상적으로 동작하지 않았다. 로그 상으로는 디바">
<meta name="generator" content="Hugo 0.121.2">


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">


  
    
    <link rel="stylesheet" href="/css/img.css">
  

  
    
    <link rel="stylesheet" href="/css/noto_sans_kr.css">
  

  
    
    <link rel="stylesheet" href="/css/nanumgothic.css">
  


<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />

 
    
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-Y7VW74D2P3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css" integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js" integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js" integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>




  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>Home</a>
	
	<a href="/posts">Archive</a>
	<a href="/tags">Tags</a>
	<a href="/about">About</a>

	

	
	  <a class="button" href="/index.xml">Subscribe</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">안드로이드의 uevent, ueventd</h1>

    <div class="tip">
        <time datetime="2020-01-30 23:34:30 &#43;0900 KST">Jan 30, 2020</time>
        <span class="split">
          ·
        </span>
        <span>
          1639 words
        </span>
        <span class="split">
          ·
        </span>
        <span>
          4 minute read
        </span>
    </div>

    
    
        
  


    


    <div class="content">
      <h1 id="개요">개요 <a href="#%ea%b0%9c%ec%9a%94" class="anchor">🔗</a></h1><p>디바이스 트리와 카메라 포팅에 관련된 디바이스 드라이버 코드를 적절하게 수정한 뒤에도 계속해서 디바이스가 정상적으로 동작하지 않았다. 로그 상으로는 디바이스 OPEN에 실패하는 것으로 나왔는데, 원인은 다른 곳에 있었다. <code>ueventd.rc</code> 파일을 수정하지 않아 관련된 디바이스 노드 파일에 대한 권한이 설정되지 않았던 것이 문제였다.</p>
<p>본 포스팅에서는 <code>uevent</code>와 <code>ueventd</code>가 무엇인지 살펴보고 안드로이드 init 과정에서 어떻게 활용되는지 살펴보기로 한다.</p>
<p>여담으로 안드로이드의 uevent는 리눅스의 udev 와 비슷한 역할을 하면서도 조금 다르다. 리눅스의 일반적인 환경 구성이 devfs + udev 로 디바이스 노드 파일들을 관리한다면, 안드로이드는 <code>ueventd</code>를 이용하여 노드 파일들을 관리한다.</p>
<h1 id="uevent--ueventd">uevent &amp; ueventd <a href="#uevent--ueventd" class="anchor">🔗</a></h1><p>리눅스에서는 디바이스 노드 파일을 생성할 수 있도록 <code>mknod</code> 유틸리티를 제공하지만 안드로이드에서는 보안 문제로 이를 제공하지 않는다. 때문에, 안드로이드의 init 프로세스는 아래의 두 가지 방식으로 디바이스 노드를 생성한다.</p>
<ul>
<li>hot plug: 시스템 동작 중 디바이스 장치가 삽입될 때 이에 대한 이벤트 처리로 <code>ueventd</code>를 거쳐 해당 장치의 디바이스 노드 파일을 동적으로 생성한다.</li>
<li>cold plug: 미리 정의된 디바이스 정보를 바탕으로 init 프로세스가 실행될 때 일괄적으로 디바이스 노드 파일을 생성한다.</li>
</ul>
<p>출처에 따르면 cold plug 방식에 대해서, <code>ueventd</code>가 실행되기 전에 디바이스 드라이버가 /sys 디렉토리 아래에 디바이스 노드를 생성하기 위한 정보들을 저장한 후, <code>ueventd</code>가 실행되면서 디바이스 노드를 생성하지 못한 디바이스 드라이버에 대해서 강제로 uevent 를 발생시켜 cold plug 처리를 한다고 설명하고 있다.</p>
<h1 id="init-process와-ueventd">init process와 ueventd <a href="#init-process%ec%99%80-ueventd" class="anchor">🔗</a></h1><p>안드로이드 init 과정에서 <code>ueventd</code>를 부른다. <code>ueventd</code> 에서는 내부적으로 아래의 <code>ueventd_main</code> 함수를 호출한다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">ueventd_main</span>(<span style="color:#0b0;font-weight:bold">int</span> argc, <span style="color:#0b0;font-weight:bold">char</span> <span style="color:#666">**</span>argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">pollfd</span> ufd;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> nr;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">char</span> tmp[<span style="color:#666">32</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">/* Prevent fire-and-forget children from becoming zombies.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">    * If we should need to wait() for some children in the future
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">    * (as opposed to none right now), double-forking here instead
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">    * of ignoring SIGCHLD may be the better solution.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">    */</span>
</span></span><span style="display:flex;"><span>    signal(SIGCHLD, SIG_IGN);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    open_devnull_stdio();
</span></span><span style="display:flex;"><span>    klog_init();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    INFO(<span style="">“</span>starting ueventd<span style="">\</span>n<span style="">”</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">/* Respect hardware passed in through the kernel cmd line. Here we will look
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">     * for androidboot.hardware param in kernel cmdline, and save its value in
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">     * hardware[]. */</span>
</span></span><span style="display:flex;"><span>    import_kernel_cmdline(<span style="color:#666">0</span>, import_kernel_nv);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    get_hardware_name(hardware, <span style="color:#666">&amp;</span>revision);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ueventd_parse_config_file(<span style="">“</span><span style="color:#666">/</span>ueventd.rc<span style="">”</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    snprintf(tmp, <span style="color:#a2f;font-weight:bold">sizeof</span>(tmp), <span style="">“</span><span style="color:#666">/</span>ueventd.<span style="color:#666">%</span>s.rc<span style="">”</span>, hardware);
</span></span><span style="display:flex;"><span>    ueventd_parse_config_file(tmp);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    device_init();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ufd.events <span style="color:#666">=</span> POLLIN;
</span></span><span style="display:flex;"><span>    ufd.fd <span style="color:#666">=</span> get_device_fd();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">1</span>) {
</span></span><span style="display:flex;"><span>        ufd.revents <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        nr <span style="color:#666">=</span> poll(<span style="color:#666">&amp;</span>ufd, <span style="color:#666">1</span>, <span style="color:#666">-</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (nr <span style="color:#666">&lt;=</span> <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (ufd.revents <span style="color:#666">==</span> POLLIN)
</span></span><span style="display:flex;"><span>               handle_device_fd();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>여기서 중요한 함수는 <code>ueventd_parse_config_file</code>와 <code>device_init</code>함수이다. <code>ueventd_parse_config_file</code>함수는 <code>ueventd.rc</code>파일과 <code>ueventd.%hardware%.rc</code> 파일을 읽어 디바이스 노드 파일을 만드는 정보를 얻는다. 이 파일에 저장되어 있는 정보는 device 이름, permission, gid, uid 이다. 아래는 업무에서 사용한 실제 ueventd.rc 파일로서 문제가 된 videosource에 대한 내용들이 추가되어야 했다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>/dev/switch_gpio_reverse	0666	system		system
</span></span><span style="display:flex;"><span>#/dev/videosource* 로 가능
</span></span><span style="display:flex;"><span>/dev/videosource0	0666	system		system
</span></span><span style="display:flex;"><span>/dev/videosource1	0666	system		system
</span></span></code></pre></div><p>이 때, 별도로 저장되어 있지 않는 디바이스는 디폴트로 600, 0, 0이 세팅된다. <code>device_init</code> 함수는 <code>uevent_socket</code>을 열고 coldboot 함수를 실행한다.</p>
<p>여기서 연 소켓은 uevent를 보낼때 쓰이는 것이 아니라 나중에 발생한 uevent를 받을때 쓰인다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">device_init</span>(<span style="color:#0b0;font-weight:bold">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    suseconds_t t0, t1;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">stat</span> info;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> fd;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">/* is 64K enough? udev uses 16MB! */</span>
</span></span><span style="display:flex;"><span>    device_fd <span style="color:#666">=</span> uevent_open_socket(<span style="color:#666">64</span><span style="color:#666">*</span><span style="color:#666">1024</span>, <span style="color:#a2f">true</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(device_fd <span style="color:#666">&lt;</span> <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fcntl(device_fd, F_SETFD, FD_CLOEXEC);
</span></span><span style="display:flex;"><span>    fcntl(device_fd, F_SETFL, O_NONBLOCK);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (stat(coldboot_done, <span style="color:#666">&amp;</span>info) <span style="color:#666">&lt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>        t0 <span style="color:#666">=</span> get_usecs();
</span></span><span style="display:flex;"><span>        coldboot(<span style="">“</span><span style="color:#666">/</span>sys<span style="color:#666">/</span><span style="color:#a2f;font-weight:bold">class</span><span style="">”);</span>
</span></span><span style="display:flex;"><span>        coldboot(<span style="">“</span><span style="color:#666">/</span>sys<span style="color:#666">/</span>block<span style="">”</span>);
</span></span><span style="display:flex;"><span>        coldboot(<span style="">“</span><span style="color:#666">/</span>sys<span style="color:#666">/</span>devices<span style="">”</span>);
</span></span><span style="display:flex;"><span>        t1 <span style="color:#666">=</span> get_usecs();
</span></span><span style="display:flex;"><span>        fd <span style="color:#666">=</span> open(coldboot_done, O_WRONLY<span style="color:#666">|</span>O_CREAT, <span style="color:#666">0000</span>);
</span></span><span style="display:flex;"><span>        close(fd);
</span></span><span style="display:flex;"><span>        log_event_print(<span style="">“</span>coldboot <span style="color:#666">%</span>ld uS<span style="">\</span>n<span style="">”</span>, ((<span style="color:#0b0;font-weight:bold">long</span>) (t1 <span style="">–</span> t0)));
</span></span><span style="display:flex;"><span>    } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        log_event_print(<span style="">“</span>skipping coldboot, already done<span style="">\</span>n<span style="">”</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>호출되는 coldboot는 내부적으로 <code>do_coldboot</code>를 호출한다.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">do_coldboot</span>(DIR <span style="color:#666">*</span>d)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">dirent</span> <span style="color:#666">*</span>de;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> dfd, fd;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dfd <span style="color:#666">=</span> dirfd(d);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fd <span style="color:#666">=</span> openat(dfd, <span style="">“</span>uevent<span style="">”</span>, O_WRONLY);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(fd <span style="color:#666">&gt;=</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>        write(fd, <span style="">“</span>add<span style="">\</span>n<span style="">”</span>, <span style="color:#666">4</span>);
</span></span><span style="display:flex;"><span>        close(fd);
</span></span><span style="display:flex;"><span>        handle_device_fd();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>((de <span style="color:#666">=</span> readdir(d))) {
</span></span><span style="display:flex;"><span>        DIR <span style="color:#666">*</span>d2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(de<span style="color:#666">-&gt;</span>d_type <span style="color:#666">!=</span> DT_DIR <span style="color:#666">||</span> de<span style="color:#666">-&gt;</span>d_name[<span style="color:#666">0</span>] <span style="color:#666">==</span> <span style="">‘</span>.<span style="">’</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        fd <span style="color:#666">=</span> openat(dfd, de<span style="color:#666">-&gt;</span>d_name, O_RDONLY <span style="color:#666">|</span> O_DIRECTORY);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(fd <span style="color:#666">&lt;</span> <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        d2 <span style="color:#666">=</span> fdopendir(fd);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(d2 <span style="color:#666">==</span> <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>            close(fd);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            do_coldboot(d2);
</span></span><span style="display:flex;"><span>            closedir(d2);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>디바이스 노드를 생성하지 못한 디바이스가 저장한 /sys 밑의 각각의 해당 폴더를 들어가 <code>uevent</code> 파일에 “add” 메시지를 써넣어 강제로 uevent를 발생시킨다. 그 후 <code>handle_device_fd</code> 함수를 통해 <code>uevent</code> 를 파싱해 디바이스 노드를 만든다. 이 과정에서 <code>ueventd_parse_config_file</code> 에서 얻어온 정보를 사용한다.</p>
<h1 id="출처">출처 <a href="#%ec%b6%9c%ec%b2%98" class="anchor">🔗</a></h1><ul>
<li><a href="https://kshokd.wordpress.com/2012/08/29/init-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-uevent%EC%99%80-ueventd%EC%9D%98-%ED%99%9C%EC%9A%A9/" target="_blank" rel="noopener">https://kshokd.wordpress.com/2012/08/29/init-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-uevent%EC%99%80-ueventd%EC%9D%98-%ED%99%9C%EC%9A%A9/</a></li>
</ul>

    </div>

    
        <div class="tags">
            
                <a href="/tags/uevent">uevent</a>
            
                <a href="/tags/ueventd">ueventd</a>
            
        </div>
    
    
    

</section>


    </main>
    
    <footer id="footer">
    

    <div class="copyright">
    
        Copyright - Sukbeom Kim
    
    </div>

    
</footer>



  </body>
</html>

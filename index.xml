<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>평범한 개발자</title>
    <link>/</link>
    <description>Recent content on 평범한 개발자</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Sep 2024 22:39:58 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>이맥스 Tree-sitter Major Mode 구현</title>
      <link>/posts/%EC%9D%B4%EB%A7%A5%EC%8A%A4-tree-sitter-major-mode-%EA%B5%AC%ED%98%84/</link>
      <pubDate>Mon, 09 Sep 2024 22:39:58 +0900</pubDate>
      <guid>/posts/%EC%9D%B4%EB%A7%A5%EC%8A%A4-tree-sitter-major-mode-%EA%B5%AC%ED%98%84/</guid>
      <description>이 글에서는 이맥스에서 bitbake tree-sitter parser를 사용하기 위해 major mode를 구현하는 방법을 소개한다. Syntax Tree Generator 출현 Tree-sitter1 는 소스 코드를 syntax tree로 만드는 &amp;lsquo;parser generator tool</description>
    </item>
    <item>
      <title>Vterm In Emacs</title>
      <link>/posts/vterm-in-emacs/</link>
      <pubDate>Sat, 19 Aug 2023 00:00:00 +0000</pubDate>
      <guid>/posts/vterm-in-emacs/</guid>
      <description>Overview Using Emacs in daily life, I rely on vterm terminal emulator instead of eshell. However, I&amp;#39;ve noticed that there are certain limitations in terms of integration between vterm and Emacs. While the package supports some user-accessible functions, they are not sufficient. I&amp;#39;ve always wanted the integration level as VSCode, and at least it should be able to open files from the terminal interface. Well, this is one of essential features of the terminal emulator running on editors, so I thought that having this kind of issue was ridiculous.</description>
    </item>
    <item>
      <title>라즈베리파이 네트워크 부팅 설정</title>
      <link>/posts/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B6%80%ED%8C%85-%EC%84%A4%EC%A0%95/</link>
      <pubDate>Sat, 15 Apr 2023 10:21:58 +0900</pubDate>
      <guid>/posts/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B6%80%ED%8C%85-%EC%84%A4%EC%A0%95/</guid>
      <description>네트워크 부팅 환경 설정 기본적으로 라즈베리파이의 경우 SD 카드에 부트에 필요한 파티션들을 저장한다. 이 때문에 커널이나 루트파일시스템의 수정사항이 있는 경우 매</description>
    </item>
    <item>
      <title>Fwnode</title>
      <link>/posts/fwnode/</link>
      <pubDate>Sun, 19 Mar 2023 17:45:39 +0900</pubDate>
      <guid>/posts/fwnode/</guid>
      <description>fwnode에 대해서는 자료가 거의 없는 것 같다. 너무 쉬운 개념이라 없는 건지 관심이 없어서 그런 것인지는 모르겠으나 개인적으로는 단번에 이해되지가 않았고 참고</description>
    </item>
    <item>
      <title>strcpy</title>
      <link>/posts/strcpy/</link>
      <pubDate>Sun, 09 Oct 2022 14:00:05 +0900</pubDate>
      <guid>/posts/strcpy/</guid>
      <description>개요 한달 전 회사에서 리눅스 디바이스 드라이버 코드에 MISRA-C, CERT-C 룰셋들을 이용하여 정적분석을 하는 도중, strcpy 에 대한 warning 을 어떻게 처리할까 고민하다가 LWN 에서 Ushering out strlcpy() 라는 기</description>
    </item>
    <item>
      <title>프로세스 종료와 파일 디스크립터</title>
      <link>/posts/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A2%85%EB%A3%8C%EC%99%80-%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0/</link>
      <pubDate>Tue, 10 May 2022 00:03:20 +0900</pubDate>
      <guid>/posts/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A2%85%EB%A3%8C%EC%99%80-%ED%8C%8C%EC%9D%BC-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0/</guid>
      <description>파일을 open 했는데 close를 안하면? stdin(0), stdout(2), stderr(3) 이라는 정해진 공식과 함께 리다이렉션과 파이프의 개념만으로도 흥분하던 대학교 시절에 내가 알던 파일 디스크립터의 정</description>
    </item>
    <item>
      <title>Device Tree Overlay</title>
      <link>/posts/device-tree-overlay/</link>
      <pubDate>Sun, 08 May 2022 01:37:45 +0900</pubDate>
      <guid>/posts/device-tree-overlay/</guid>
      <description>Ramoops 덕분에 알게된 오버레이 며칠전 리눅스에서의 Tracing 방법에 대해 공부하다가 찾아낸 세미나 영상에서 ramoops 라는 것을 알게 되었다. ramoops는 커널이 oops/panic 이 발생하면서</description>
    </item>
    <item>
      <title>Stack Protector와 디버깅 이야기</title>
      <link>/posts/stack-protector%EC%99%80-%EB%94%94%EB%B2%84%EA%B9%85-%EC%9D%B4%EC%95%BC%EA%B8%B0/</link>
      <pubDate>Thu, 03 Feb 2022 15:00:45 +0900</pubDate>
      <guid>/posts/stack-protector%EC%99%80-%EB%94%94%EB%B2%84%EA%B9%85-%EC%9D%B4%EC%95%BC%EA%B8%B0/</guid>
      <description>Stack Protector, 넌 뭐하는 놈이냐? 현업에서 커널의 CONFIG_STACK_PROTECTOR 를 활성화하면 커널 부트가 안된다는 이슈가 보고되었다. Trace32 로 callstack을 살펴보니 내 파트에서 맡고 있는 디바이</description>
    </item>
    <item>
      <title>컴파일 타임에 매크로 변수 값 확인하기</title>
      <link>/posts/%EC%BB%B4%ED%8C%8C%EC%9D%BC-%ED%83%80%EC%9E%84%EC%97%90-%EB%A7%A4%ED%81%AC%EB%A1%9C-%EB%B3%80%EC%88%98-%EA%B0%92-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/</link>
      <pubDate>Sat, 16 Oct 2021 02:19:05 +0900</pubDate>
      <guid>/posts/%EC%BB%B4%ED%8C%8C%EC%9D%BC-%ED%83%80%EC%9E%84%EC%97%90-%EB%A7%A4%ED%81%AC%EB%A1%9C-%EB%B3%80%EC%88%98-%EA%B0%92-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/</guid>
      <description>&lt;h1 id=&#34;개요&#34;&gt;개요&lt;/h1&gt;&#xA;&lt;p&gt;현업에서 사용하는 코드 중 상당히 많은 부분들이 매크로 변수 형태로 정의되어&#xA;사용되고 있다. 이러한 변수들은 런타임 때 정의되지 않기 때문에 굳이 값을 확인하기&#xA;위해서 불필요하게 런타임에서까지 확인해볼 필요는 없지만, 통상적으로 이러한&#xA;변수들의 값이 어떻게 설정되어 있는지에 대한 로깅 코드들이 많이 있다.&lt;/p&gt;&#xA;&lt;p&gt;그렇다면, 컴파일 타임에서 매크로 변수의 값을 알 수 있는 방법은 없을까? #pragma&#xA;와 같은 전처리 키워드를 사용하면 가능하다. 예를 들어, 아래의 코드를 보자.&lt;/p&gt;</description>
    </item>
    <item>
      <title>커널의 KASAN 코드가 삽입되는 방법</title>
      <link>/posts/%EC%BB%A4%EB%84%90%EC%9D%98-kasan-%EC%BD%94%EB%93%9C%EA%B0%80-%EC%82%BD%EC%9E%85%EB%90%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</link>
      <pubDate>Fri, 24 Sep 2021 01:13:41 +0900</pubDate>
      <guid>/posts/%EC%BB%A4%EB%84%90%EC%9D%98-kasan-%EC%BD%94%EB%93%9C%EA%B0%80-%EC%82%BD%EC%9E%85%EB%90%98%EB%8A%94-%EB%B0%A9%EB%B2%95/</guid>
      <description>커널의 KASAN 코드가 삽입되는 방법 Generic KASAN 의 경우, 위와 같이 __asan_load와 __asan_store 함수가 정의되어 있다. 단순하게 KASAN의 사용법만 보았을 때, 과연 커널에</description>
    </item>
    <item>
      <title>V4L2 Memory Type</title>
      <link>/posts/v4l2-memory-type/</link>
      <pubDate>Sun, 18 Apr 2021 00:32:27 +0900</pubDate>
      <guid>/posts/v4l2-memory-type/</guid>
      <description>개요 최근 Capture 디바이스 드라이버 코드의 V4L2 표준화 작업을 위해 한 가지 업무를 할당 받았다. 거의 일주일 동안 헤매었는데 다른 선임 개발자가 몇 시간 만에 코드를 수정하니 기</description>
    </item>
    <item>
      <title>Kernel Debug With Kgdb</title>
      <link>/posts/kernel-debug-with-kgdb/</link>
      <pubDate>Tue, 13 Apr 2021 23:31:41 +0900</pubDate>
      <guid>/posts/kernel-debug-with-kgdb/</guid>
      <description>개요 필자에게는 디버깅이 현업에서 가장 많은 시간을 소모하는 일이다. 업무 효율을 위해서 디버깅 하는 방법을 찾던 도중 커널에서 제공하는 kdb와 kgdb를 이용하</description>
    </item>
    <item>
      <title>__is_constexpr macro in kernel</title>
      <link>/posts/__is_constexpr-macro-in-kernel/</link>
      <pubDate>Sun, 21 Mar 2021 22:44:03 +0900</pubDate>
      <guid>/posts/__is_constexpr-macro-in-kernel/</guid>
      <description>커널에서 한 가지 재미있는(?) 매크로를 발견했다. 깊이 살펴보고 나니, GCC로 컴파일 시에 삼항 연산자를 이러한 방식으로 사용할 수 있다는 점에 한 번 놀랐고 이러</description>
    </item>
    <item>
      <title>Mac에서 GDB 이용한 커널 해킹하기</title>
      <link>/posts/mac%EC%97%90%EC%84%9C-gdb-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BB%A4%EB%84%90-%ED%95%B4%ED%82%B9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Sat, 20 Feb 2021 02:43:54 +0900</pubDate>
      <guid>/posts/mac%EC%97%90%EC%84%9C-gdb-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BB%A4%EB%84%90-%ED%95%B4%ED%82%B9%ED%95%98%EA%B8%B0/</guid>
      <description>개요 맥에서도 GDB 를 이용하여 커널 디버깅을 하려고 여러 방법을 시도해보았지만 쉽게 되지 않았다. 리눅스 커널 컴파일부터 qemu 실행, gdb attach 까지 단번에 되는게 하나도 없었</description>
    </item>
    <item>
      <title>WSL 리소스 조정하기</title>
      <link>/posts/wsl-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EC%A1%B0%EC%A0%95%ED%95%98%EA%B8%B0/</link>
      <pubDate>Sat, 28 Nov 2020 23:00:00 +0900</pubDate>
      <guid>/posts/wsl-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EC%A1%B0%EC%A0%95%ED%95%98%EA%B8%B0/</guid>
      <description>개요 커널 분석을 위해 WSL을 이용하도록 환경을 구성하자 서브시스템에서 사용하는 메모리나 CPU 자원이 상당하였다. 16기가 램 중에 무려 12기가를 사용하는 일이</description>
    </item>
    <item>
      <title>리누즈게이트와 CoC</title>
      <link>/posts/%EB%A6%AC%EB%88%84%EC%A6%88%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%99%80-coc/</link>
      <pubDate>Sat, 05 Sep 2020 09:50:58 +0900</pubDate>
      <guid>/posts/%EB%A6%AC%EB%88%84%EC%A6%88%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%99%80-coc/</guid>
      <description>자유 발언 구독 중인 «LXer Linux News»에서 Linusgate Leaked 라는 제목으로 글 하나가 올라왔다. 글을 읽고 나서 최근 고민하던 문제인 &amp;lsquo;개발자에게 중요한 것은</description>
    </item>
    <item>
      <title>커널에서의 Object-Oriented Design Pattern</title>
      <link>/posts/%EC%BB%A4%EB%84%90%EC%97%90%EC%84%9C%EC%9D%98-object-oriented-design-pattern/</link>
      <pubDate>Sat, 25 Jul 2020 16:25:23 +0900</pubDate>
      <guid>/posts/%EC%BB%A4%EB%84%90%EC%97%90%EC%84%9C%EC%9D%98-object-oriented-design-pattern/</guid>
      <description>개요 현업에서 BSP 코드를 수정하다가 문득 든 생각은 &amp;lsquo;왜 객체 지향의 디자인 패턴을 적용하지 않는 걸까?&amp;rsquo; 라는 것이다. 그러한 디자인 패턴</description>
    </item>
    <item>
      <title>맥 OS에서 리눅스 커널 컴파일하기</title>
      <link>/posts/%EB%A7%A5-os%EC%97%90%EC%84%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90-%EC%BB%B4%ED%8C%8C%EC%9D%BC%ED%95%98%EA%B8%B0/</link>
      <pubDate>Sun, 12 Jul 2020 22:13:08 +0900</pubDate>
      <guid>/posts/%EB%A7%A5-os%EC%97%90%EC%84%9C-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%84%90-%EC%BB%B4%ED%8C%8C%EC%9D%BC%ED%95%98%EA%B8%B0/</guid>
      <description>개요 맥 환경에서 bare-metal이 아닌 리눅스 커널로 컴파일하는 것은 생각했던 것보다 까다롭다. BSD 계열이기는 하지만 커널 컴파일에 필요한 라이브러리와 경</description>
    </item>
    <item>
      <title>mu4e 설정하기</title>
      <link>/posts/mu4e-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/</link>
      <pubDate>Fri, 26 Jun 2020 01:36:36 +0900</pubDate>
      <guid>/posts/mu4e-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/</guid>
      <description>개요 이맥스에서는 이메일 클라이언트로서 사용할 수 있는 mu4e라는 패키지가 있다. 일반적으로 isync (mbsync) 라는 프로그램과 함께 사용하며 mu 를 설치하면 설치 디렉토리 내</description>
    </item>
    <item>
      <title>Do While</title>
      <link>/posts/do-while/</link>
      <pubDate>Wed, 01 Apr 2020 23:55:32 +0900</pubDate>
      <guid>/posts/do-while/</guid>
      <description>개요 커널 매크로에 do { .. } while(0) 구문을 사용하는 것을 보게 되었다. 사내 코드에서도 이러한 구문들이 많이 보였는데 처음에는 의미없이 이상하게 짜여진 코드라고 생각했</description>
    </item>
    <item>
      <title>BSD 버전 Linked List</title>
      <link>/posts/bsd-%EB%B2%84%EC%A0%84-linked-list/</link>
      <pubDate>Wed, 01 Apr 2020 00:26:52 +0900</pubDate>
      <guid>/posts/bsd-%EB%B2%84%EC%A0%84-linked-list/</guid>
      <description>개요 사내에서 소스 파일에 대한 라이센스를 정리하기 시작하면서 기존 애플리케이션에서 리눅스의 pipe 를 이용하여 구현된 메세지 큐를 연결 리스트로 재작성하는 작업을 맡</description>
    </item>
    <item>
      <title>C ARRAY_SIZE 매크로와 포인터 기초</title>
      <link>/posts/c-array_size-%EB%A7%A4%ED%81%AC%EB%A1%9C%EC%99%80-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EA%B8%B0%EC%B4%88/</link>
      <pubDate>Sat, 28 Mar 2020 00:54:01 +0900</pubDate>
      <guid>/posts/c-array_size-%EB%A7%A4%ED%81%AC%EB%A1%9C%EC%99%80-%ED%8F%AC%EC%9D%B8%ED%84%B0-%EA%B8%B0%EC%B4%88/</guid>
      <description>개요 칩 검증 코드를 수정하기 위해 간단한 루틴을 작성하고 있던 도중 커널에서 제공하는 ARRAY_SIZE 매크로가 의도한대로 동작하지 않아 살펴보기 시작했다. 그러던 도중 https://kldp.org/node/34268 과 같은</description>
    </item>
    <item>
      <title>poll() 그리고 poll_wait()</title>
      <link>/posts/poll-%EA%B7%B8%EB%A6%AC%EA%B3%A0-poll_wait/</link>
      <pubDate>Tue, 10 Mar 2020 23:52:01 +0900</pubDate>
      <guid>/posts/poll-%EA%B7%B8%EB%A6%AC%EA%B3%A0-poll_wait/</guid>
      <description>개요 업무 중에 카메라 드라이버에 관련된 이슈를 보다가 poll()과 poll_wait()이 지속적으로 사용되는 것을 볼 수 있었다. 이슈에 관련된 커널이 다소</description>
    </item>
    <item>
      <title>ioctl()에 전달되는 cmd 관련 매크로 함수</title>
      <link>/posts/ioctl%EC%97%90-%EC%A0%84%EB%8B%AC%EB%90%98%EB%8A%94-cmd-%EA%B4%80%EB%A0%A8-%EB%A7%A4%ED%81%AC%EB%A1%9C-%ED%95%A8%EC%88%98/</link>
      <pubDate>Thu, 27 Feb 2020 00:23:10 +0900</pubDate>
      <guid>/posts/ioctl%EC%97%90-%EC%A0%84%EB%8B%AC%EB%90%98%EB%8A%94-cmd-%EA%B4%80%EB%A0%A8-%EB%A7%A4%ED%81%AC%EB%A1%9C-%ED%95%A8%EC%88%98/</guid>
      <description>드라이버 코드 내에서 ioctl commands 를 정의하기 위해 단순 integer를 사용하는 게 아니라 매크로를 통해 생성을 하고 있었다. 이에 관련 내용을 포스팅과 함께 정리하고자 한</description>
    </item>
    <item>
      <title>Likely and Unlikely</title>
      <link>/posts/likely-and-unlikely/</link>
      <pubDate>Thu, 13 Feb 2020 23:27:51 +0900</pubDate>
      <guid>/posts/likely-and-unlikely/</guid>
      <description>개요 예전에 관리하던 블로그에서 커널에서 사용하는 likely와 unlikely 에 대해서 정리한 포스팅이 있었다. 하지만 시간이 지나 커널 분석 책을 다시 보며 likely, unlike</description>
    </item>
    <item>
      <title>typedef is evil</title>
      <link>/posts/typedef-is-evil/</link>
      <pubDate>Thu, 13 Feb 2020 01:12:37 +0900</pubDate>
      <guid>/posts/typedef-is-evil/</guid>
      <description>커널 쪽의 코드를 보다가 문득 커널 코드에 적용하는 코딩 규칙에 대해서 궁금해졌다. 관련 내용으로 검색하다보니 재미있는 포스팅 하나를 발견했다. typedef is evil 이라는 제목</description>
    </item>
    <item>
      <title>이맥스 기본 에디터로 사용하기</title>
      <link>/posts/%EC%9D%B4%EB%A7%A5%EC%8A%A4-%EA%B8%B0%EB%B3%B8-%EC%97%90%EB%94%94%ED%84%B0%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Sun, 09 Feb 2020 03:09:59 +0000</pubDate>
      <guid>/posts/%EC%9D%B4%EB%A7%A5%EC%8A%A4-%EA%B8%B0%EB%B3%B8-%EC%97%90%EB%94%94%ED%84%B0%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>개요 이맥스를 메인으로 사용하는 환경을 위해서 필요한 몇 가지 설정 값에 대해 포스팅하고자 한다. 이맥스의 경우 다른 vim 과 마찬가지로 초기 로드가 상당히 오래 걸리는 편</description>
    </item>
    <item>
      <title>ftrace 이용한 커널 디버깅</title>
      <link>/posts/ftrace-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BB%A4%EB%84%90-%EB%94%94%EB%B2%84%EA%B9%85/</link>
      <pubDate>Thu, 06 Feb 2020 23:43:34 +0900</pubDate>
      <guid>/posts/ftrace-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BB%A4%EB%84%90-%EB%94%94%EB%B2%84%EA%B9%85/</guid>
      <description>개요 커널 디버깅을 위해 procfs, sysfs, 레지스터 덤프 등의 단순 정보를 제외한 다른 방법은 없을까? 업무에서 문제 원인 파악을 위해서는 디버깅이 중요한데 커널에서는 사용할 수 있</description>
    </item>
    <item>
      <title>GPIO Mapping</title>
      <link>/posts/gpio-mapping/</link>
      <pubDate>Fri, 31 Jan 2020 23:48:06 +0900</pubDate>
      <guid>/posts/gpio-mapping/</guid>
      <description>GPIO 맵핑하기 오늘은 gpio 맵핑을 위해 디바이스 트리를 이용하였지만 정상적으로 설정되지 않는 문제가 있었다. SoC에서 GPIO Enable 에 대한 것이 문제일 것이라 예상되지만, GPIO</description>
    </item>
    <item>
      <title>안드로이드의 uevent, ueventd</title>
      <link>/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%9D%98-uevent-ueventd/</link>
      <pubDate>Thu, 30 Jan 2020 23:34:30 +0900</pubDate>
      <guid>/posts/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%9D%98-uevent-ueventd/</guid>
      <description>개요 디바이스 트리와 카메라 포팅에 관련된 디바이스 드라이버 코드를 적절하게 수정한 뒤에도 계속해서 디바이스가 정상적으로 동작하지 않았다. 로그 상으로는 디바이</description>
    </item>
    <item>
      <title>Little Endian vs. Big Endian</title>
      <link>/posts/little-endian-vs.-big-endian/</link>
      <pubDate>Mon, 27 Jan 2020 22:27:06 +0900</pubDate>
      <guid>/posts/little-endian-vs.-big-endian/</guid>
      <description>개요 빅 엔디안과 리틀 엔디안에 관해 업무에서 접할 수 있는 상황과 각각에 해당하는 포인터 연산 예제를 종합적으로 정리하도록 한다. 엔디안(Endianness)</description>
    </item>
    <item>
      <title>색 공간(Color Space)</title>
      <link>/posts/%EC%83%89-%EA%B3%B5%EA%B0%84color-space/</link>
      <pubDate>Sun, 26 Jan 2020 16:39:36 +0900</pubDate>
      <guid>/posts/%EC%83%89-%EA%B3%B5%EA%B0%84color-space/</guid>
      <description>색 공간 포맷 업무 상에 사용되는 일반적인 색 인코딩 시스템은 RGB 와 YUV 이다. 그 중에서도 SoC의 각 컴포넌트에서 이미지 처리를 위해 기본으로 요구하는 포맷은 YUV 이다.</description>
    </item>
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Sat, 25 Jan 2020 22:47:44 +0900</pubDate>
      <guid>/about/</guid>
      <description>이맥스를 사용하지만 VI 키 바인딩을 사용합니다. Gentoo Linux와 Arch Linux는 사랑하지만 Ubuntu WSL를 사용합니다. FSF의 철학을 좋아합니다. 인성도 중요한</description>
    </item>
    <item>
      <title>Major와 Minor Numbers</title>
      <link>/posts/major%EC%99%80-minor-numbers/</link>
      <pubDate>Fri, 31 May 2019 18:37:25 +0900</pubDate>
      <guid>/posts/major%EC%99%80-minor-numbers/</guid>
      <description>세마포어를 이용한 모듈 프로그래밍을 하던 중 Major, Minor 라는 개념이 등장하였다. 인터넷으로 찾은 커널 모듈 소스가 구버전 커널을 기준으로 한 까닭에, 커널 코드가 어떻게 변</description>
    </item>
    <item>
      <title>지피(Jiffies)</title>
      <link>/posts/%EC%A7%80%ED%94%BCjiffies/</link>
      <pubDate>Sun, 26 May 2019 10:38:40 +0900</pubDate>
      <guid>/posts/%EC%A7%80%ED%94%BCjiffies/</guid>
      <description>오랜만에 지피에 대한 포스팅을 다시 작성한다(대학생 때 커널 공부를 한 뒤로 이렇게 별도로 문서를 작성하는 것은 처음인 것 같다). 전역 변수인 jiffies에는 시</description>
    </item>
    <item>
      <title>Linux 커널, Busybox 빌드 후 QEMU에서 실행하기(2/2)</title>
      <link>/posts/linux-%EC%BB%A4%EB%84%90-busybox-%EB%B9%8C%EB%93%9C-%ED%9B%84-qemu%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B02/2/</link>
      <pubDate>Thu, 23 May 2019 15:10:46 +0900</pubDate>
      <guid>/posts/linux-%EC%BB%A4%EB%84%90-busybox-%EB%B9%8C%EB%93%9C-%ED%9B%84-qemu%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B02/2/</guid>
      <description>지난 번 포스팅에서는 단순하기 initramfs 램디스크를 만들어 busybox에 올리는 방법을 기술했었다. 그러면서 램디스크가 무엇인지 busybox는 무엇인지, 그리</description>
    </item>
    <item>
      <title>Linux 커널, Busybox 빌드 후 QEMU에서 실행하기(1/2)</title>
      <link>/posts/linux-%EC%BB%A4%EB%84%90-busybox-%EB%B9%8C%EB%93%9C-%ED%9B%84-qemu%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B01/2/</link>
      <pubDate>Wed, 22 May 2019 19:35:04 +0900</pubDate>
      <guid>/posts/linux-%EC%BB%A4%EB%84%90-busybox-%EB%B9%8C%EB%93%9C-%ED%9B%84-qemu%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B01/2/</guid>
      <description>취업은 언제하나&amp;hellip; 커널 공부를 할 게 아니라 취업을 위한 알고리즘을 공부해야 하는데 커널 해킹을 위한 환경 구축만 하고 공부하자는 것이 꼬리에 꼬리를 물</description>
    </item>
    <item>
      <title>CORS(Cross-Origin Resource Sharing)</title>
      <link>/posts/corscross-origin-resource-sharing/</link>
      <pubDate>Wed, 01 May 2019 17:20:49 +0900</pubDate>
      <guid>/posts/corscross-origin-resource-sharing/</guid>
      <description>CORS(Cross-Origin Resource Sharing) 웹 보안 정책 중 Same-Origin Policy는 한 출처(Origin)에서 로드된 문서나 스크립트가 다른 출처 자원과 상호작용하지 못하도록 제약한다. 언급한 출처(O</description>
    </item>
  </channel>
</rss>
